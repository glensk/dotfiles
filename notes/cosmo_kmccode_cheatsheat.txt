self.nsites = 64  # for a 4^3 supercell
self.nvac = 1 # or 2; the number of vacancies in the system
self.natoms = self.nsites - self.nvac

self.dbeads[0].q[0,:]): --> actual positions (in bohrradius)
self.sites[self.unique_idx(self.state)].copy()*bohr_to_ang

self.sites:   # (undisturbed lattice sites) ---> those NEVER change during simulation
[[ 0.          0.          0.        ]
 [ 2.71055907  1.56494201  4.42632442]
...
 [29.81614973 17.21436208  8.85264884]
 [32.5267088  18.77930408 13.27897326]]

self.state:  ['S' 'S' 'S' 'M' 'M' 'M' 'A' 'A' 'A' 'A' ....'V' 'A' 'A' ]
ostr = "".join(self.state): e.g. AAAAAAAMAAASAAAAMAAAAAAAAAAASASAAMAAAAVA...
nstr =                      e.g. AAAAAAAMAAASAAAAMAAAAAAAAAAASASAAMAAAAVA...
nstate = self.state.copy()  : ['S' 'S' 'S' 'M' 'M' 'M' 'A' 'A' 'A' 'A' ....'V' 'A' 'A' ]
nstate[svac], nstate[sneigh] = self.state[sneigh], self.state[svac]   : ['S' 'S' 'S' 'M' 'M' 'M' 'A' 'A' 'A' 'A' ....'V' 'A' 'A' ]

self.sites[self.unique_idx(nstate)]
self.sites[self.unique_idx(self.state)]
print(self.sites[self.unique_idx(self.state)])

self.ecache_file -> contains nevent[2]
self.qcache_file -> contains nevent[3]
nevent = [svac, sneigh, 0.0              , 0.0              , 0.0]  # initialization
nevent = [svac, sneigh, self.ecache[nstr], self.qcache[nstr], 0.0]
nevent[-1] = self.state[sneigh]  # this is just an "A" or an "S" or an "M"
nevent[2] = self.ecache[nstr] : energy of the corresponding structure?
nevent[2] = self.qcache[nstr] : positions of the corresponding strucure?

ivac (constant): is always the index lattice site associated the vacancy (e.g. 63 when 64 sites)
ivac (constant): if 64 atoms sits & 1vac -> ivac = [63]
ivac (constant): if 64 atoms sits & 2vac -> ivac = [63 ,62]

svac = self.idx[ivac] # lattice !site! associated with this vacancy; ivac is fixed but self.idx array changes with every swap.
svac: index of the current vacancy position which changes with every KMC step

nvac: index of a partiuclar neighbor of the vacancy

print('this is how one can get the positions of the solutes')
print('self.idx[0]',self.idx[0]  ,"self.state[self.idx[0]] == self.state[7] :",self.state[self.idx[0]])
print('self.idx[1]',self.idx[1]  ,"self.state[self.idx[1]] == self.state[25]:",self.state[self.idx[1]])
print('self.idx[2]',self.idx[2]  ,"self.state[self.idx[2]] == self.state[53]:",self.state[self.idx[2]])
print('self.idx[3]',self.idx[3]  ,"self.state[self.idx[3]] == self.state[40]:",self.state[self.idx[3]])
print('self.idx[4]',self.idx[4]  ,"self.state[self.idx[4]] == self.state[xx]:",self.state[self.idx[4]])
print('self.idx[5]',self.idx[5]  ,"self.state[self.idx[5]] == self.state[xx]:",self.state[self.idx[5]])
print('self.idx[63]',self.idx[63],"self.state[self.idx[63]]== self.state[35]:",self.state[self.idx[63]])
This is how one can get the positions of the solutes:
('self.idx[0]', 7, 'self.state[self.idx[0]] == self.state[7] :', 'S')
('self.idx[1]', 25, 'self.state[self.idx[1]] == self.state[25]:', 'S')
('self.idx[2]', 53, 'self.state[self.idx[2]] == self.state[53]:', 'S')
('self.idx[3]', 40, 'self.state[self.idx[3]] == self.state[40]:', 'M')
('self.idx[4]', 22, 'self.state[self.idx[4]] == self.state[xx]:', 'M')
('self.idx[5]', 33, 'self.state[self.idx[5]] == self.state[xx]:', 'M')
('self.idx[63]', 35, 'self.state[self.idx[63]]== self.state[35]:', 'V')
check: fidis: /home/glensk/kmc_ipi_play/4x4x4_n2p2_v2ag_300K_1Vac_3Mg_3Si__1.563pctVac_4.688pctMg_4.688pctSi_10.0rcut/seed985635



self.neigh  # list of nearest neighbors; if 64 atoms in the system (4x4x4sc) this is an array of 12 elements in 64 rows. 
            # self.neigh is a fixed list and never changes

ridx: [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
 48 49 63 51 52 53 54 55 56 57 58 59 60 61 62 50]
ridx: # reverse lookup index [i.e. ridx[i] gives the index of the atoms/vacancy at site i] (where the 'site' is the original site when the simulation started) 

idx: connects the initial positions of the atoms 
# atoms are ordered (at the beginning) by [ S,S,S,M,M,M,A,A,....,V]
# atoms are ordered (at the beginning) by [ S1,S2,S3,M1,M2,M3,A,A,....,V]
self.idx[0] says ALWAYS! where** S1 is now (where** = on which index = on which lattie site with respect to original lattice) 
self.idx[1] says ALWAYS! where** S2 is now (where** = on which index = on which lattie site with respect to original lattice) 
self.idx[3] says ALWAYS! where** M1 is now (where** = on which index = on which lattie site with respect to original lattice) 
self.idx[atom] will give the index of the atom where atom is the index of the initial atom (as stored in the simulations_pos.out file)
self.idx[ivac] : is sorted in such a way that last position gives alwasy the index 
to the vacancy.

svac = self.idx[ivac]  # ivac is consatnt = 63
      (self.idx is changed with every swap to connect to original lattice sites)
sneigh = self.neigh[svac] -> loop over all neighbors
		is every neighbor of vacancy self.neigh[svac]


in self.ridx tauschen immer svac <--> sneigh  (das ausgesuchte sneigh)

in self.idx  tauschen immer ivac <--> ineigh  

ineigh = self.ridx[sneigh] # gets index of atom associated with the neighboring site

%cat vacancy_pos_unwrapped_ka_0.txt
[17.21239301  9.93757974  7.02693002] svac 63 sneigh 50 ivac 63 ineigh 50
[11.47492868  1.65626329  4.68462002] svac 50 sneigh 54 ivac 63 ineigh 54
[12.90929476  4.14065823  4.68462002] svac 54 sneigh 5  ivac 63 ineigh 5
[2.86873217 3.31252658 2.34231001]    svac 5  sneigh 6  ivac 63 ineigh 6
[4.30309825 4.14065823 4.68462002]    svac 6  sneigh 2  ivac 63 ineigh 2

difference between idx und ridx:
step 0:
atom 50 geht auf vacancy position 63 -> site 50 is now vacant
svac = 50
 idx [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
 48 49 63 51 52 53 54 55 56 57 58 59 60 61 62 50]
ridx [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
 48 49 63 51 52 53 54 55 56 57 58 59 60 61 62 50]
 idx[63] = atom = 50 
ridx[63] = atom = 50
 idx[50] = vac  = 63
ridx[50] = vac  = 63
self.idx[ivac=63] (=50) -> gives always the index of where the vacancy is currently
self.ridx[svac] is always ivac == 63
self.idx[ivac] is always svac == 50
self.ridx[ivac=63] (=50) -> gives always the index of where the vacancy is currently

step 1:
atom 54 geht auf vacancy position 50: -> site 54 is now vacant
svac = 54
 idx [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
 48 49 63 51 52 53 50 55 56 57 58 59 60 61 62 54]  -> shows 
ridx [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
 48 49 54 51 52 53 63 55 56 57 58 59 60 61 62 50]
 idx[63] = 54
ridx[63] = 54
 idx[50] = 63
ridx[50] = 63
self.idx[ivac=63] (54) -> gives always the index of where the vacancy is currently
self.ridx[svac] is always ivac == 63
self.idx[ivac] is always svac == 54
self.ridx[ivac=63] (54) -> gives always the index of where the vacancy is currently

self.idx[63]  = 54 -> original site 63 is currently on site 54 
self.ridx[54] = 63 -> current site 54 is originally from site 54 
self.ridx[svac]    -> always 63 (for every step)
self.sites[54]     -> always gives array([24.3950316 ,  7.82471003,  8.85264884])
				   -> for every step

