#!/usr/bin/env python

import math
import numpy as np
import sys
import os
import hesse as pot_energy
reload(pot_energy)
import utils
import crystal_generator





def get_fit_forces_to_pot(filename = False, NN = False, pot = False, data = False, foldername = "", verbose = True):
    ''' fits forces to morse, lj, mc1 '''
    import copy
    filenameorig = copy.copy(filename)
    filename = foldername+filename
    if type(data) == bool:
        if type(filename) == bool:
            sys.exit("please provide a filename")
        if os.path.isfile(filename) != True:
            sys.exit("file "+filename+" does not exist")
        data=np.loadtxt(filename)
    else:
        data = data
    #alat =  float(filename.split("_")[-1])
    #NN = alat/np.sqrt(2.)
    if type(NN) == bool:
        if pot == '135' or pot == '1357' or pot == '13579':
            pass
        else:
            sys.exit("please provide NN")
    if type(NN) == str:
        NN= float(NN)
    if type(pot) == False:
        sys.exit("please define a pot")

    datax=data[:,0]
    datay=data[:,1]
    from scipy import optimize
    if pot == 'l':
        parameters, function_covariance = \
            optimize.curve_fit(lambda r, eps: pot_energy.LJ_derivative(r, eps, NN), datax, datay, maxfev=1000)
    if pot == 'm':
        parameters, function_covariance = \
            optimize.curve_fit(lambda r, De, aa: pot_energy.Morse_derivative(r, De, aa, NN), datax, datay,p0=[0.02, 1.96], maxfev=10000000)
            #optimize.curve_fit(Morse_derivativeNN, data[:,0], data[:,1], maxfev=1000)
    if pot == 'mc1':
        parameters, function_covariance = \
            optimize.curve_fit(lambda r, De, aa, A, B: pot_energy.mc1_derivative(r, De, aa, NN, A, B), datax, datay, maxfev=1000000)
    if pot == '135':
        parameters, function_covariance = \
            optimize.curve_fit(Trans135_der, datax, datay, maxfev=10000)
    if pot == '1357':
        parameters, function_covariance = \
            optimize.curve_fit(Trans1357_der, datax, datay, maxfev=10000)
    if pot == '13579':
        parameters, function_covariance = \
            optimize.curve_fit(Trans13579_der, datax, datay, maxfev=10000)


    print "NN:",NN,"pot:",pot,"parameters:",parameters,utils.printred(function_covariance)
    fitx = np.linspace(datax.min()-1.0,datax.max()+1.0, num=100)
    if pot == 'l':
        #fity = LJ_derivative(fitx, parameters[0], NN)
        fity = pot_energy.LJ_derivative(fitx, 0.0342863, NN)
    if pot == 'm':
        fity = pot_energy.Morse_derivative(fitx, parameters[0], parameters[1], NN)
        fitdelta = pot_energy.Morse_derivative(datax, parameters[0], parameters[1], NN) - datay
        deltas = np.transpose([datax, fitdelta])
        #print "fd:",fitdelta
    if pot == 'mc1':
        fity = pot_energy.mc1_derivative(fitx, parameters[0], parameters[1], NN, \
                parameters[2], parameters[3])
        fitdelta = pot_energy.mc1_derivative(datax, parameters[0], parameters[1], NN, \
                parameters[2], parameters[3]) - datay
        deltas = np.transpose([datax, fitdelta])

# delta to fit

    #print "saving..."
    deltasfolder = foldername+"/deltas/"
    deltasfolderfit = foldername+"/deltasfit/"
    if len(deltasfolder.split("/")) > 14:
        print "deltasfolder:",deltasfolder,len(deltasfolder)
        print "in get_fit_forces_to_pot!"
        sys.exit("deltasfolder is wrong")
    if os.path.isdir(deltasfolder) != True: os.makedirs(deltasfolder)
    if os.path.isdir(deltasfolderfit) != True: os.makedirs(deltasfolderfit)

    deltasfolderfilename = deltasfolder+filenameorig+"_fit_delta___"+str(parameters[0])[:8]
    if len(deltasfolderfilename.split("/")) > 14:
        print "deltasfolderfilename:",deltasfolderfilename
        print "in get_fit_forces_to_pot!"
        sys.exit("deltasfolder is wrong")

    #print "--- fit deltas -------"
    #print "filenameorig:",filenameorig
    deltadata = np.transpose([datax, -fitdelta])
    #print "deltasfolderfit:",deltasfolderfit
    polyfit(
    foldername=deltasfolderfit,
    filename=filenameorig+"_add_",
            zeroat=NN,
            data=deltadata,
            verbose2=False)

    if pot == 'l':
        np.savetxt(
            filename+"_fit_lj_"+str(parameters[0])[:8]
            +"_"+str(NN)[:8],
                np.transpose([fitx, fity]),
                fmt='%.18f',
                delimiter='  ')   # X is an array

    if pot == 'm':
        if type(filename) != bool:
            np.savetxt(
                filename+"_fit___"+str(parameters[0])[:8]
                +"_"+str(parameters[1])[:8]
                +"_"+str(NN)[:8],
                    np.transpose([fitx, fity]),
                    fmt='%.18f',
                    delimiter='  ')   # X is an array
            np.savetxt(
                deltasfolder+filenameorig+"_fit_delta___"+str(parameters[0])[:8]
                +"_"+str(parameters[1])[:8]
                +"_"+str(NN)[:8],
                    deltadata,
                    fmt='%.18f',
                    delimiter='  ')   # X is an array
    if pot == 'mc1':
        if type(filename) != bool:
            np.savetxt(
                filename+"_fit___"+str(parameters[0])[:8]
                +"_"+str(parameters[1])[:8]
                +"_"+str(NN)[:8]
                +"_"+str(parameters[2])[:8]
                +"_"+str(parameters[3])[:8],
                    np.transpose([fitx, fity]),
                    fmt='%.18f',
                    delimiter='  ')   # X is an array
            print "filenameorig:",filenameorig
            np.savetxt(
                deltasfolder+filenameorig+"_fit_delta___"+str(parameters[0])[:8]
                +"_"+str(parameters[1])[:8]
                +"_"+str(NN)[:8]
                +"_"+str(parameters[2])[:8]
                +"_"+str(parameters[3])[:8],
                    deltadata,
                    fmt='%.18f',
                    delimiter='  ')   # X is an array
    return parameters



def polyfit_with_fixed_points(n, x, y, xf, yf) :
    #print "n:",n
    #print "x:",x
    #print "y:",y
    #print "xf:",xf,type(xf)
    #print "yf:",yf,type(yf)
    #print n,len(xf),type(n),type(len(xf))
    mat = np.empty((n + 1 + len(xf),) * 2)
    vec = np.empty((n + 1 + len(xf),))
    x_n = x**np.arange(2 * n + 1)[:, None]
    yx_n = np.sum(x_n[:n + 1] * y, axis=1)
    x_n = np.sum(x_n, axis=1)
    idx = np.arange(n + 1) + np.arange(n + 1)[:, None]
    mat[:n + 1, :n + 1] = np.take(x_n, idx)
    xf_n = xf**np.arange(n + 1)[:, None]
    mat[:n + 1, n + 1:] = xf_n / 2
    mat[n + 1:, :n + 1] = xf_n.T
    mat[n + 1:, n + 1:] = 0
    vec[:n + 1] = yx_n
    vec[n + 1:] = yf
    #print "mat:",mat
    #print "vec:",vec
    params = np.linalg.solve(mat, vec)
    return params[:n + 1]

def polyfit(filename = False, zeroat = False, ordermax = False, data = False, dataxminfit= False, dataxmaxfit = False, verbose = False, verbose2=False, foldername = "", return_deltasfilename = False ):
    ''' fits data in filename to polynomial of order x '''
    import copy
    filenameorig = copy.copy(filename)
    #print "foldername>>>:",foldername
    #print "filename>>>:",filename
    if type(foldername) == bool and type(filename) == bool:
        filename = foldername
    else:
        filename = foldername+filename
    if type(data) == bool:
        if type(filename) == bool:
            sys.exit("please provide a filename or data")
        if os.path.isfile(filename) != True:
            sys.exit("file "+filename+" does not exist")
        data=np.loadtxt(filename)
    else:
        data = data

    if type(zeroat) == bool:
        sys.exit("arguments 1: valid Filename; 2: zeroat;")
    datax=data[:,0]
    datay=data[:,1]
    #print "#################: datax:",zeroat
    #print datax
    #print "#################: datay:",zeroat
    #print datay

    # calculate polynomial
    #coefs = np.polyfit(datax, datay, order)
    if ordermax == False:
        ordermax = datax.shape[0]/2.
        if ordermax > 9:
            ordermax = 9
    else:
        ordermax = int(ordermax)
    #print "ordermax:",ordermax

    orderstry = np.arange(1,ordermax+1)  # 7 goes to only to order 6

    def findbestpolyfit(datax,datay,zeroat,orderstry,dataxminfit,dataxmaxfit):
        #ordermaxdelta = np.zeros((ordermax+1,20))
        ordermaxdelta = np.zeros((len(orderstry),18))
        ordermaxdelta[:] = np.nan
        for orderidx,order in enumerate(orderstry):
            ordermaxdelta[orderidx,0] = order
            order = int(order)
            #print ""
            if verbose:
                print "order    :",order,type(int(order))
                print "zeroat   :",zeroat,type(float(zeroat))
            coefs = polyfit_with_fixed_points(int(order),datax,datay,np.array([float(zeroat)]),np.array([0.0]))  # coefs for forces
            e0 = np.polyint(np.poly1d(coefs[::-1]))(float(zeroat))
            #coefs[0] = coefs[0] + e0
            #print "coefs",coefs


            # coefs:    coefs for forces
            # coefse:   coefs for energy
            coefse = np.polyint(coefs[::-1])[::-1]  # turn coefs for foces into coefs for energy
            coefse[0] = -e0
            e = np.poly1d(coefs[::-1])(float(zeroat))
            f = np.polyder(np.poly1d(coefse[::-1]))(float(zeroat))

            # get coefs as those would be read in (==used)
            # We want to do this to see how much of accuracy we loose due to exporting a
            # finite number of digits

            coefsstringforces = pot_energy.list_to_string(coefs)
            coefsrealforces = pot_energy.string_to_list(coefsstringforces)

            coefsstringene = pot_energy.list_to_string(coefse)
            coefsrealene = pot_energy.string_to_list(coefsstringene)

            if verbose:
                print "coefs:",coefs
            er = np.poly1d(coefsrealene[::-1])(float(zeroat))
            fr = np.polyder(np.poly1d(coefsrealene[::-1]))(float(zeroat))
            function = np.polyder(np.poly1d(coefsrealene[::-1]))
            if verbose:
                print "function:",function

            # calculate new x's and y's
            if type(dataxminfit) == bool:
                dataxminfit = datax.min()-1
            if type(dataxmaxfit) == bool:
                dataxmaxfit = datax.max()+1
            fitx = np.linspace(dataxminfit,dataxmaxfit, num=101)
            fity = function(fitx)

            fitdelta = function(datax) - datay
            fitdeltamax = abs(fitdelta).max()
            #print "fitdeltamax:",'%f' % fitdeltamax
            #ft = np.poly1d(coefs[::-1])(float(zeroat))
            #et = np.polyint(np.poly1d(coefsrealene[::-1]))(float(zeroat))
            #f = np.poly1d(coefs[::-1])(float(zeroat))
            #e = np.polyint(np.poly1d(coefsrealene[::-1]))(float(zeroat))
            #coefse = np.polyint(np.poly1d(coefsrealene[::-1]))
            #print ""
            ordermaxdelta[orderidx,1] = fitdeltamax
            ordermaxdelta[orderidx,2] = er - e
            ordermaxdelta[orderidx,3] = fr - f
            if False:
                print "order:",order, '%f' % fitdeltamax,"f:",f,"e:",e,"er:",er,"fr:",fr #,"coefs:",coefs
            #print "coefs:",coefs
            #print "coefse:",coefse
            #print "coefse:",coefse
        return ordermaxdelta,fitdelta,coefsstringene,coefsrealene,coefsstringforces,coefsrealforces,order,fitx,fity




    #print "orderstry:",orderstry
    ###############################################################################################################################
    # try fit with several orders 1 ... 9  (orderstry)
    ###############################################################################################################################
    ordermaxdelta,fitdelta,coefsstringene,coefsrealene,coefsstringforces,coefsrealforces,order,fitx,fity = findbestpolyfit(datax,datay,zeroat,orderstry,dataxminfit,dataxmaxfit)
    if verbose2:
        print "(order)      (dforce)  (er - e)  (fr - f)"
        np.set_printoptions(linewidth=240)    # print only 6 digist after .
        print ordermaxdelta
        print "xxxxxxyy"
        print ordermaxdelta[:,1].argmin()
        print ordermaxdelta.argmin()
        print "-------"
    #orderstry = np.arange(1,ordermax+1)  # 7 goes to only to order 6
    ###############################################################################################################################
    # now get the best fitted function (np.arange(ordermaxdelta[:,1].argmin()+1,ordermaxdelta[:,1].argmin()+2))
    ###############################################################################################################################
    ordermaxdelta,fitdelta,coefsstringene,coefsrealene,coefsstringforces,coefsrealforces,order,fitx,fity = findbestpolyfit(datax,datay,zeroat,
            np.arange(ordermaxdelta[:,1].argmin()+1,ordermaxdelta[:,1].argmin()+2),
            dataxminfit,dataxmaxfit)
    if verbose2:
        print ordermaxdelta
        print "-------"
    deltas = np.transpose([datax, -fitdelta])
    deltamax = fitdelta



    #deltasfilename = deltasfolder+filenameorig+"_poly"+str(int(ordermax))+"_"+str(int(order))+"_delta___"+coefsstringene,
    #deltasfilename = filenameorig+"_poly"+str(int(ordermax))+"_"+str(int(order))+"_delta___"+coefsstringene
    #print "kkb:>>>",datax,datay,"<<<"
    #print "filename33:",filename,type(filename)

    if type(filename) != bool:
        #deltasfolder = os.getcwd()+"/"+foldername+"/deltas/"
        deltasfolder = foldername+"/deltas/"
        if len(deltasfolder.split("/")) > 14 or len(deltasfolder.split("/")) < 8:
            print "len:",len(deltasfolder.split("/"))
            print "foldername:",foldername
            print "deltasfolder:",deltasfolder
            print "in polyfit!"
            sys.exit("deltasfolder is wrong")

        deltasfolderfilename = deltasfolder+filenameorig+"_poly"+str(int(ordermax))+"_"+str(int(order))+"_delta___"+coefsstringene
        if len(deltasfolderfilename.split("/")) > 14:
            print "deltasfolderfilename:",deltasfolderfilename
            print "in polyfit!"
            sys.exit("deltasfolder is wrong")

        if os.path.isdir(deltasfolder) != True: os.makedirs(deltasfolder)
        #print "writing:",filename+"_"+str(int(order))+"_order_fit___"+coefsstringene,
        np.savetxt(
            filename+"_poly"+str(int(ordermax))+"_"+str(int(order))+"_fit___"+coefsstringene,
                np.transpose([fitx, fity]),
                fmt='%.18f',
                delimiter='  ')   # X is an array
        np.savetxt(
                # filenameorig seems always to be
                deltasfolder+filenameorig+"_poly"+str(int(ordermax))+"_"+str(int(order))+"_delta___"+coefsstringene,
                deltas,
                #np.transpose([datax, fitdelta]),  # here fitdelta is not in agrement with fit_pot ... which is negative
                fmt='%.18f',
                delimiter='  ')   # X is an array
    #return fitdelta
    #print "cfd:",coefsrealene
    #print "2;",coefsrealforces
    #print "3;",deltas
    if return_deltasfilename:
        return deltasfilename
    else:
        return coefsrealene,coefsrealforces,deltas




def getforcepot(longvec,pot,potparam,pot2 = False):
    usepot=['nan','nan','nan','nan','nan','nan','nan']
    if pot == 'm': usepot[0] = "Morse"
    if pot == 'l': usepot[0] = "LJ"
    if pot == 'i': usepot[0] = "inversepot"
    if pot == 'mc1': usepot[0] = "mc1"
    for idx,p in enumerate(potparam):
        usepot[idx+1] = float(p)

    longvecnorm=np.linalg.norm(longvec)
    getfrompot2 = False
    if type(pot2) != bool:
        if usepot[0] == "Morse" or usepot[0] == "mc1":
            NNdist = float(pot2[3])
            #print "NNdist:",NNdist,longvecnorm
            if longvecnorm > NNdist:
                getfrompot2 = True
        else:
            sys.exit("pot2 only m or mc1")

    if usepot[0] == "inversepot":
        elong = pot_energy.inversepot(longvecnorm,usepot[1],usepot[2],usepot[3])
        flongnorm = pot_energy.inversepot_derivative(longvecnorm,usepot[1],usepot[2],usepot[3])

    if usepot[0] == "Morse":
        if getfrompot2 == False:
            elong = pot_energy.Morse(longvecnorm,usepot[1],usepot[2],usepot[3])
            flongnorm = pot_energy.Morse_derivative(longvecnorm,usepot[1],usepot[2],usepot[3])
        else:
            if pot2[0] != 'm':
                sys.exit("not m")
            elong =                Morse(longvecnorm,float(pot2[1]),float(pot2[2]),float(pot2[3]))
            flongnorm = Morse_derivative(longvecnorm,float(pot2[1]),float(pot2[2]),float(pot2[3]))


    if usepot[0] == "mc1" or usepot[0] == 'mc1':
        #print "usepot:",usepot
        if getfrompot2 == False:
            elong = pot_energy.mc1(longvecnorm,usepot[1],usepot[2],usepot[3],usepot[4],usepot[5])
            flongnorm = pot_energy.mc1_derivative(longvecnorm,usepot[1],usepot[2],usepot[3],usepot[4],usepot[5])
        else:
            if pot2[0] != 'mc1':
                print "pot2:",pot2
                sys.exit("not mc1")
            elong =                pot_energy.mc1(longvecnorm,float(pot2[1]),float(pot2[2]),float(pot2[3]),float(pot2[4]),float(pot2[5]))
            flongnorm = pot_energy.mc1_derivative(longvecnorm,float(pot2[1]),float(pot2[2]),float(pot2[3]),float(pot2[4]),float(pot2[5]))


    if usepot[0] == "LJ":
        elong = pot_energy.LJ(longvecnorm,usepot[1],usepot[2])
        flongnorm = pot_energy.LJ_derivative(longvecnorm,usepot[1],usepot[2])

    # flong ist die longitudinale Kraft
    flong = longvec/longvecnorm*flongnorm   # der volle vektor == voller longitudinale vektor
    if flong[0] == -0.0:
        flong[0] = 0.0
    if flong[1] == -0.0:
        flong[1] = 0.0
    if flong[2] == -0.0:
        flong[2] = 0.0
    #print np.around(flong[0],decimals=7),np.around(flong[1],decimals=7),np.around(flong[2],decimals=7)
    return flong




class forcesneighbors( object ):
    '''
    for fcc:
    form quer we want to get    long 1NN (  this appears to be pure compared to the
                                            x-direction which contains also an inplane
                                            part)

    from xdir we want to get    long 1NN (this we can get also quer disp might be better)
                                long 2NN
                                tox 1NN
                                tox 2NN

    analyzes the forces of the different neighbor shells
    this class is designed for a certain alat which has to be defined beforehand
    f[1]    : all forces of first alat WRONG NOW
    f[1,1]  : all forces of first alat and first displacement WRONG NOW
    f[1,1,1]: all forces fo first alat and first displacement in x,y,z direction WRONG NOW
    '''
    def __init__(self):
        self.a       = None      # alat
        self.xquer   = None      # defines if the current displacement is a disp in x or
                                 # quer direction
        self.sc      = None
        self.folder  = None      # list of folders
        self.dnorm   = None      # norm of displacement (from origin) (should be of len a)
        self.dvec    = None      # vec of displacement (from origin) (should be of len a)
        self.eqcoords = np.loadtxt("EqCoords_direct")
        self.atoms = self.eqcoords.shape[0]
        self.rcar    = None
        self.f       = None
        self.p       = None      # positions (should be of lenght a)
        self.struct  = None
        if self.atoms == 54: self.struct = 'bcc'
        if self.atoms == 32: self.struct = 'fcc'
        if self.atoms == 108: self.struct = 'fcc'
        if type(self.struct) == bool:
            sys.exit("self.struct not known")


    def loadforces(self, DOScut = False, DOScutarray = False):
        print "-->>>> ",os.getcwd(),"type(DOScut):",type(DOScut)
        if os.path.isfile("nnforces.npz") == True:
            self.loadData(os.getcwd(),"nnforces")
        else:
            import utils
            self.folder = utils.lsn(str(self.a)+"Ang_"+"*")
            if len(self.folder) == 0:
                sys.exit("no folder found with name: "+str(self.a)+"Ang_"+"*")
            print ""
            for folderidx,folder in enumerate(self.folder):
                print folderidx,folder
            print ""
            ## get all lattice constants; then go thround every latticeconstant and create
            ## a sepereate datafile (data.4.13, data.4.04)
            #alats = [] # later this is a numpy array
            #for folder in folderall: # one folder = is e.g. 4.13Ang_0.3
            #    folderdetails = utils.string_to_num_list(folder)
            #    a = folderdetails[0]
            #    disp = folderdetails[1]
            #    #print a,disp,folder
            #    alats.extend([a])
            #alatslist = list(set(alats))
            #alatsarray = np.array(list(set(alats)))
            #self.a = alatsarray
            #print "a:",a



            # for every alat do auswertung
            #for a in alatslist:
            #    for folder in folderall:
            #        folderdetails = utils.string_to_num_list(folder)
            #        afolder = folderdetails[0]
            #        disp = folderdetails[1]
            #        #print a,afolder,type(a),type(afolder),a==afolder
            #        #if a == afolder:
            #        if a == afolder: # and a == takealat:
            #            ## here we will only have the corresponding alat
            #            print folder,a,disp

            self.f = np.zeros((np.array(self.folder).shape[0],self.atoms,3))
            self.p = np.zeros((np.array(self.folder).shape[0],self.atoms,3))
            self.e = np.zeros(np.array(self.folder).shape[0])
            self.dstring = range(len(self.folder))
            self.dvec = np.zeros((np.array(self.folder).shape[0],3))
            self.dnorm = np.zeros((np.array(self.folder).shape[0]))


            for folderidx,folder in enumerate(self.folder):
                folderdetails = utils.string_to_num_list(folder)
                afolder = folderdetails[0]
                disp = folderdetails[1]


                # if DOScut:
                #if DOScut == True:
                #    self.jobvorlage_DOSloncut = DOScutarray
                #    self.jobvorlage_DOSloncut_max = self.jobvorlage_DOSloncut[:,0].max()
                #    self.jobvorlage_DOSloncut_min = self.jobvorlage_DOSloncut[:,0].min()
                #    print "disp:",disp,type(disp)
                #    print "min:",self.jobvorlage_DOSloncut_min
                #    print "...:",self.nn
                #    print "max:",self.jobvorlage_DOSloncut_max
                #    sys.exit()
                # if disp nicht innnerhalb DOScut
                # aget DOS



                #print self.f[folderidx]
                self.dstring[folderidx] = disp
                self.dvec[folderidx] = self.p[folderidx][0]



                if os.path.isfile("tmp"):
                    os.remove("tmp")
                if os.path.isfile("tmpene"):
                    os.remove("tmpene")
                print "folder:",folder
                utils.run2("OUTCAR_forces-last-ARRAY.sh "+folder+" > tmp")
                self.f[folderidx] = np.loadtxt("tmp")
                if os.path.isfile("tmp"):
                    os.remove("tmp")

                utils.run2("OUTCAR_positions-last-ARRAY.sh "+folder+" > tmp")
                utils.run2("OUTCAR_ene-free-last.sh "+folder+" > tmpene")
                self.p[folderidx] = np.loadtxt("tmp")
                self.e[folderidx] = np.loadtxt("tmpene")
                if os.path.isfile("tmp"):
                    os.remove("tmp")
                if os.path.isfile("tmpene"):
                    os.remove("tmpene")

                #utils.run2("POSCAR_cell_cartesian.sh "+folder+" > tmp")
                utils.run2("OUTCAR_cell-last-cartesian-ARRAY.sh "+folder+" > tmp")
                self.sc = np.loadtxt("tmp")
                if os.path.isfile("tmp"):
                    os.remove("tmp")


                ## if self.dvec
                if self.dvec[folderidx][0] > 4.0:
                    self.dvec[folderidx][0] = self.dvec[folderidx][0] - self.sc[0,0]
                if self.dvec[folderidx][1] > 4.0:
                    self.dvec[folderidx][1] = self.dvec[folderidx][1] - self.sc[0,0]
                self.dnorm[folderidx] = np.linalg.norm(self.p[folderidx][0])
                print disp
            if self.dvec[0,1] == 0.0:
                self.xquer = 'x'
            else:
                self.xquer = 'q'


            # get other variables
            allposforces = np.zeros((self.p.shape[0]*self.p.shape[1]+self.atoms,6))  # + self.atoms um die erste (unausgelenkte struktur) hinzuzufuegen
            allpos = self.p.flatten().reshape(self.p.shape[0]*self.p.shape[1],3)
            allforces = self.f.flatten().reshape(self.f.shape[0]*self.f.shape[1],3)
            allposforces[self.atoms:,0:3] = allpos
            allposforces[self.atoms:,3:6] = allforces


            # ene_vs_disp
            #np.savetxt("POSITIONs",self.p.flatten().reshape(self.p.shape[0]*self.p.shape[1],3))
            self.positions = allposforces.reshape(self.p.shape[0]*self.p.shape[1]+self.atoms,6)
            self.ene_vs_disp = np.array((self.dstring,self.e)).transpose()

            # POSITIONs
            minidx = np.nonzero(self.ene_vs_disp[:,0] == 0.0)[0][0]
            minene = self.ene_vs_disp[minidx][1]
            minposforces = self.positions[minidx*self.atoms+self.atoms:minidx*self.atoms+self.atoms+self.atoms]
            self.positions[:self.atoms] = minposforces

            # udftmev_vs_disp
            udftmev = (self.ene_vs_disp[:,1] - minene)*1000/(self.atoms)
            self.udftmev_vs_disp = np.array((self.dstring,udftmev)).transpose()

            # dUdL
            self.dudl = np.zeros((np.array(self.folder).shape[0],9))
            self.dudl[:,4] = self.udftmev_vs_disp[:,1]
            self.dudl[:,0] = self.udftmev_vs_disp[:,0]

            self.saveData(os.getcwd(),"nnforces")
            np.savetxt("ene_vs_disp",self.ene_vs_disp)
            np.savetxt("POSITIONs",self.positions,fmt="%.8f")
            np.savetxt("udftmev_vs_disp",self.udftmev_vs_disp)
            np.savetxt("dUdL",self.dudl,fmt="%7.3f%10.1f%9.1f%9.1f%14.2f%10.2f%14.2f%10.2f%10.2f",header=" step   time(fs)  temp(K) average       U(meV/at)    Uref          dUdL   average    offset")

            print "self.dvec",self.dvec


            takeevery = 1
            print "lines:",self.dudl.shape[0]
            if self.dudl.shape[0] > 100:  # 100 - 200
                takeevery = 6
            if self.dudl.shape[0] > 200:
                takeevery = 8
            if self.dudl.shape[0] > 300:
                takeevery = 10
            positions_short = self.positions[self.atoms:].flatten().reshape(self.dudl.shape[0],self.atoms*6)[::takeevery]
            nr1 = positions_short.shape[0]
            nr2 = positions_short.shape[1]
            tmppositions_short = positions_short.flatten().reshape(nr1*nr2/6,6)
            #print "kkk:",tmppositions_short.shape
            self.positions_short = np.zeros((tmppositions_short.shape[0]+self.atoms,6))
            self.positions_short[:self.atoms] = self.positions[:self.atoms]
            self.positions_short[self.atoms:] = tmppositions_short

            self.dudl_short = self.dudl[::takeevery]
            self.ene_vs_disp_short = self.ene_vs_disp[::takeevery]
            self.udftmev_vs_disp_short = self.udftmev_vs_disp[::takeevery]
            print self.udftmev_vs_disp_short

            np.savetxt("ene_vs_disp_short",self.ene_vs_disp_short)
            np.savetxt("POSITIONs_short",self.positions_short,fmt="%.8f")
            np.savetxt("udftmev_vs_disp_short",self.udftmev_vs_disp_short)
            np.savetxt("dUdL_short",self.dudl_short,fmt="%7.3f%10.1f%9.1f%9.1f%14.2f%10.2f%14.2f%10.2f%10.2f",header=" step   time(fs)  temp(K) average       U(meV/at)    Uref          dUdL   average    offset")
        return







    def saveData( self, outdir, outfname ):
        '''
        '''
        print "-?:",outdir,"/",outfname
        np.savez_compressed( outdir + "/" + outfname,
                f       = self.f,
                p       = self.p,
                dstring = self.dstring,
                dvec    = self.dvec,
                dnorm   = self.dnorm,
                atoms   = self.atoms,
                eqcoords = self.eqcoords,
                folder   = self.folder,
                sc       = self.sc,
                xquer    = self.xquer,
                a       = self.a,
                positions = self.positions,
                ene_vs_disp = self.ene_vs_disp,
                dudl    = self.dudl,
                udftmev_vs_disp = self.udftmev_vs_disp,
                struct  = self.struct,
                e       = self.e
                )
        return

    def saveDatafits( self, outdir, outfname ):
        '''
        '''
        np.savez_compressed( outdir + "/" + outfname,
                nnxdist = self.nnxdist
                )
        return


    def loadData( self, indir, infname ):
        '''
        '''
        var = np.load( indir + "/" + infname + ".npz" )
        self.f          = var['f']
        self.p          = var['p']
        self.dstring    = var['dstring']
        self.dvec       = var['dvec']
        self.dnorm      = var['dnorm']
        self.atoms      = var['atoms']
        self.eqcoords   = var['eqcoords']
        self.folder     = var['folder']
        self.sc         = var['sc']
        self.xquer      = var['xquer']
        self.struct     = var['struct']
        self.a          = var['a']
        self.positions  = var['positions']
        self.ene_vs_disp = var['ene_vs_disp']
        self.dudl       = var['dudl']
        self.udftmev_vs_disp = var['udftmev_vs_disp']
        self.e          =var['e']
        return


    def loadDatafits( self, indir, infname ):
        '''
        '''
        var = np.load( indir + "/" + infname + ".npz" )
        return




    def getforces(self):
        '''
        it would be best to only do this from quer direction
        but in general we can get this from every direction
        KEEP IN MIND:
        neither morse nor mc1 are perfect (especially the attractive part)
        deviations from the strong repulsive part:
        with a d of 0.2: deviations of 0.0006 are to be expected in forces for fcc Al
        with a d of 0.3: deviations of 0.005  are to be expected in forces for fcc Al
        THIS ALSO MEANS THAT THIS ERROR WILL PROPAGATE in quantities where we substract
        the longitudinal part:
                tox (will be only "accurate" to this error, only to this displacement)
                tix ( -- "" --  )

                (-> try EVinet,EBrich, other parametrizations)

        For small displacements tox is much bigger than toy toz (factor 3);
        at x displacements of 0.5 tox is similar in magnitude to toy toz; BUT: we have to
        check the statement above once the longitudinal contribution is substractet!
        --> tox including long
        --> tox pure  ( here we should extract the quer very well fitted long part)
        '''
        import glob

        #################################################
        # get xdir or quer
        #################################################
        xdir = False
        quer = False
        q111 = False
        negside = False
        xdirfolder = False
        longreffolder = False
        querxdir = os.path.basename(os.getcwd())

        if 'negside' in querxdir: negside = True
        if 'xdir' in querxdir: xdir = True
        if 'quer' in querxdir: quer = True
        if 'q111' in querxdir: q111 = True
        if '3NNdir' in querxdir: xdir = True
        if xdir == True and quer == True:
            sys.exit("xdir and quer found in pwd, can just understand one")
        if xdir != True and quer != True and q111 != True:
            sys.exit("neither xdir, quer nor q111 found in pwd")

        #################################################
        # if xdir get corresponding quer folder
        #################################################
        def replace_right(source, target, replacement, replacements=None):
            return replacement.join(source.rsplit(target, replacements))
        # a) get NN atoms of (0/0/0) atom by using eqcoords
        # b) take the atom on (2.065,2.065,0) and opposite (-2.065,-2.065,0)
        # this here is a list for our current positions in fcc
        if self.atoms == 108:  # for fcc
            atfuncpos = 81      # [ 2.065,  2.065,  0.   ]
            atfuncneg = 105     # [ 10.325,  10.325,   0.   ]
            atlong2nnpos = 9       # [ 4.13,  0.  ,  0.  ]
            atlong2nnneg = 18      # [ 8.26,  0.  ,  0.  ]

            # works
            attox1nnpos = 27       # [ 0.   ,  2.065,  2.065]
            attox1nnneg = 27       # [ 0.   ,  2.065,  2.065]
            attox2nnpos = 3        # [ 0.  ,  4.13,  0.  ] or atom 1: [ 0.  ,  0.  ,  4.13])
            attox2nnneg = 3        # [ 0.  ,  4.13,  0.  ] or atom 1: [ 0.  ,  0.  ,  4.13])


            attix1nnpos = 87       # [2.07   10.32    0.  ]
            attix1nnneg = 99       # [2.07   10.32    0.  ]
            attiy1nnpos = 87       # [2.07   10.32    0.  ]
            attiy1nnneg = 99       # [2.07   10.32    0.  ]

            attix1nnpos = 81       # [2.07   2.07    0.  ]  # this atoms correspond to x/y basis for tix and not basis parallel and senkr to vec0
            attix1nnneg = 81       # [10.32  2.07    0.  ]
            attiy1nnpos = 81       # [2.07   2.07    0.  ]
            attiy1nnneg = 81       # [10.32  2.07    0.  ]

            attix1nnpos = 87       # [2.07   2.07    0.  ]  # this atoms correspond to x/y basis for tix and not basis parallel and senkr to vec0
            attix1nnneg = 87       # [10.32  2.07    0.  ]
            attiy1nnpos = 87       # [2.07   2.07    0.  ]
            attiy1nnneg = 87       # [10.32  2.07    0.  ]

            atlong3nnpos = 36       # array([ 4.13 ,  2.065,  2.065])
            atlong3nnneg = 53       # array([  8.26 ,  10.325,  10.325])


        if self.atoms == 32:    # for fcc 2x2x2sc
            atfuncpos = 24      # [ 2.065,  2.065,  0.   ]
            atfuncneg = 30      # [ 6.195,  6.195,  0.   ]
            atlong2nnpos = 4             # [ 4.13,  0.  ,  0.  ]
            atlong2nnneg = 4             # [ 4.13,  0.  ,  0.  ]

            # not yet
            attox1nnpos  =  8       # [ 0.     ,  2.065  ,  2.065  ]
            attox1nnneg  =  8       # [ 0.     ,  2.065  ,  2.065  ]
            attox2nnpos  =  1       # [ 0.   ,  0.   ,  4.13 ] same as [ 0.   ,  4.13 ,  0.   ],
            attox2nnneg  =  1       # [ 0.   ,  0.   ,  4.13 ] same as [ 0.   ,  4.13 ,  0.   ],
            attiatom1nn  =  16     # [ 2.065  ,  0.     ,  2.065  ]  (does not have a tox part)

            attix1nnpos = 26       # [2.07   6.07    0.  ]  # this atoms correspond to x/y basis for tix and not basis parallel and senkr to vec0
            attix1nnneg = 26       # [2.07   6.07    0.  ]
            attiy1nnpos = 26       # [2.07   6.07    0.  ]
            attiy1nnneg = 26       # [2.07   6.07    0.  ]


        if self.atoms == 54:  # bcc 3x3x3sc
            atfuncpos = 27
            atfuncneg = 53
            atlong2nnpos = 9
            atlong2nnneg = 18

            # tox
            attox1nnpos = 45        # in bcc: das 27 atom hat dann gemischt 45:  [ 7.725  ,  1.545  ,  1.545  ],
            attox1nnneg = 45
            attox2nnpos = 3        #
            attox2nnneg = 3        #











        # here we should do a loop over the corresponding neighbor
        def printatom(atom,contr,funcalld):
            print ""
            print utils.printblue("###############################################################"*2)
            print "SHELL:",atom,"    CONTRIBUTION:",contr,"   d:",funcalld
            print utils.printblue("###############################################################"*2)



        # not necessaryliy needed
        #import crystal_generator as crystal
        #crystal0 = crystal_generator.crystal()
        #crystal0.load_positions_cell(
        #    cellfile = "cell",
        #    coordfile_rrel = "EqCoords_direct")
        #NNlist1 = crystal0.get_NNlist(0, 1,
        #        cell = crystal0.cellvec,
        #        coord_rrel = crystal0.rrel,
        #        return_NNdist = True)

        self.fitfolder = os.getcwd()+'/nnforces/'
        if type(self.DOScut) != bool: #self.DOScut is a numpy array
            self.fitfolder = os.getcwd()+'/nnforcesDOScut/'

        if os.path.isdir(self.fitfolder) != True:
            os.makedirs(self.fitfolder)
        ############################################################################
        # start schleife
        ############################################################################
        to = [ 'tox', 'toy', 'toz' ]
        ti = [ 'tix', 'tiy', 'tiz' ]
        toti = [ 'tox', 'toy', 'toz', 'tix', 'tiy', 'tiz' ]
        # 0.25 and 0.35 need to be included AS FIRST d's !!! since thos are currently reference for tox
        funcalldall = [ 0.25, 0.35, 0.15, 0.2, 0.25, 0.3, 0.35 ]
        #funcalldall = [ 0.25, 0.35 ] #, 0.2, 0.25, 0.3, 0.35 ]
        funcalldall = [ 0.15, 0.2 ] #, 0.3 ]
        funcalldall = [ 0.25, 0.35 ]
        shellall       = [ 1,2,3]
        shellall       = [ 1]
        # hier ist entweder xdir == True oder quer == True or q111 == True
        for x in shellall:  # schell 1,2,3  ( == first NN, second NN, third NN ...)
            shell = str(int(x))
            ############################################################################
            # set parameters for schleifen
            ############################################################################
            # GETFORCESVEC1
            # LONTOXTIX
            #shellall       = [ 3]
            #shellall       = [ 1]
            if self.struct == 'fcc' and quer == True:   shellall = [ 1]
            if self.struct == 'fcc' and xdir == True:   shellall = [ 1]

            if xdir == True and x == 1:                 contrib = [ 'lon' , 'tox' ,'toy','toz' ,'tix', 'tiy' ]  # hier lon fuer 2NN
            if xdir == True and x == 1:                 contrib = [ 'lon' ,'tox' ] # , 'tox' ,'toy','toz' ] # ,'tix', 'tiy' ]  # hier lon fuer 2NN
            if xdir == True and x == 1:                 contrib = [ 'lon' ] # , 'tox' ,'toy','toz' ] # ,'tix', 'tiy' ]  # hier lon fuer 2NN
            #if xdir == True and x == 1:                 contrib = [ 'tix' ] # ,'tix', 'tiy' ]  # hier lon fuer 2NN
            if xdir == True and x == 2:                 contrib = [ 'lon' , 'tox' ] #, 'toy', 'toz', 'tix', 'tiy']  # hier lon fu
            if xdir == True and x == 3:                 contrib = [ 'lon' ]

            if quer == True:                            contrib = [ 'lon' , 'tox', 'toy', 'toz' , 'tix' , 'tiy' ]
            if quer == True:                            contrib = [ 'lon' , 'tix' , 'tiy' ]
            #if quer == True:                            contrib = [ 'lon' , 'tox', 'toy', 'toz' ]
            if quer == True:                            contrib = [ 'lon' ]
            #if quer == True:                            contrib = [ 'tix' ] #,'tix', 'tiy' ]
            if q111 == True:                            contrib = [ 'lon' , 'tox' ]

            if type(self.DOScut) != bool:
                # currently unclear why but I get always errors with tox when DOScut
                if xdir == True and x == 1:                 contrib = [ 'lon' ] # , 'tox' ,'toy','toz' ] # ,'tix', 'tiy' ]  # hier lon fuer 2NN
                if quer == True:                            contrib = [ 'lon' ]

            for contr in contrib:    # 'lon', 'tox', 'toy', 'toz', 'tix', 'tiy', 'tiz'
                if contr != 'lon': funcalldall = [ 1.0 ]


                printatom(x,contr,'-')

                if x == 1 and contr == 'lon' and self.struct == 'fcc' and xdir == True:
                    print "THIS WILL BE DONE IN QUER"
                    pass


                ### x == 1
                if x == 1 and contr == 'lon':
                    atpos = atfuncpos
                    atneg = atfuncneg
                if x == 1 and contr == 'tox':
                    atpos = attox1nnpos
                    atneg = attox1nnneg
                if x == 1 and contr == 'toy':
                    atpos = attox1nnpos
                    atneg = attox1nnneg
                if x == 1 and contr == 'toz':
                    atpos = attox1nnpos
                    atneg = attox1nnneg
                if x == 1 and contr == 'tix':
                    atpos = attix1nnpos
                    atneg = attix1nnneg
                if x == 1 and contr == 'tiy':
                    atpos = attix1nnpos
                    atneg = attix1nnneg

                ### x == 2
                if x == 2 and contr == 'lon':
                    atpos = atlong2nnpos
                    atneg = atlong2nnneg
                if x == 2 and contr == 'tox':
                    atpos = attox2nnpos
                    atneg = attox2nnneg

                ### x == 2
                if x == 3 and contr == 'lon':
                    atpos = atlong3nnpos
                    atneg = atlong3nnneg


                #print "XXX: x",x
                #print "CONTR:",contr
                #print "atpos:",atpos
                #print "self.p:",self.p
                #print "self.p[0,atpos]:",self.p[0,atpos]
                #print "XXX: x",x,"CONTR:",contr,"atpos:",atpos,"self.p[0,atpos]:",self.p[0,atpos]
                self.nnxdist = np.linalg.norm(self.p[0,atpos] - np.array([0.0,0.0,0.0]))


                if len(self.p[0]) == 108:
                    self.nnxdist = np.linalg.norm(self.p[0][27])
                if len(self.p[0]) == 32:
                    self.nnxdist = np.linalg.norm(self.p[0][16])

                if x == 2:
                    self.nnxdist = self.p[0,1][2]

                if x == 3:
                    self.nnxdist = np.linalg.norm(n.p[0][atlong3nnpos])

                print "self.nnxdist:",self.nnxdist
                if x == 1:
                    if self.nnxdist > 4.0:
                        sys.exit("self.nnxdist > 4.0")
                    if self.nnxdist < 2.0:
                        sys.exit("self.nnxdist < 2.0")


                # pos side + left side + 0.0 -> 1+2.*
                self.funcpos = np.zeros((np.array(self.folder).shape[0],2))
                self.funcneg = np.zeros((np.array(self.folder).shape[0],2))

                ###########################################################
                # get all posvec and all negvec
                ###########################################################
                posvecall = np.zeros((len(self.dvec),3))
                negvecall = np.zeros((len(self.dvec),3))

                for idx,i in enumerate(self.dvec):
                    coord_cart_pos = np.copy(self.p[idx])
                    crystalpos = crystal_generator.crystal()
                    crystalpos.load_positions_cell(coord_cart = coord_cart_pos, cell = self.sc)
                    crystalpos.center_atoms_around_atom(0,coord_cart=crystalpos.rcar,cell=crystalpos.cellvec)

                    coord_cart_neg = np.copy(self.p[idx])
                    crystalneg = crystal_generator.crystal()
                    crystalneg.load_positions_cell(coord_cart = coord_cart_neg, cell = self.sc)
                    crystalneg.center_atoms_around_atom(0,coord_cart=crystalneg.rcar,cell=crystalneg.cellvec)
                    #jprint "pos:",crystalpos.rcar
                    #print "neg:",crystalneg.rcar
                    #print "posvec:",crystalpos.rcar[atpos]
                    #print "negvec:",crystalneg.rcar[atneg]
                    posvec = crystalpos.rcar[atpos]
                    negvec = crystalneg.rcar[atneg]
                    #print 'posvec!;',posvec
                    #print 'nosvec!;',negvec
                    #print ",,",posvecall[idx]
                    posvecall[idx] = posvec
                    negvecall[idx] = negvec

                ###########################################################
                # get vectors (go through every dvec)
                ###########################################################
                for idx,i in enumerate(self.dvec):
                    coord_cart_pos = np.copy(self.p[idx])
                    crystalpos = crystal_generator.crystal()
                    crystalpos.load_positions_cell(coord_cart = coord_cart_pos, cell = self.sc)
                    crystalpos.center_atoms_around_atom(0,coord_cart=crystalpos.rcar,cell=crystalpos.cellvec)

                    coord_cart_neg = np.copy(self.p[idx])
                    crystalneg = crystal_generator.crystal()
                    crystalneg.load_positions_cell(coord_cart = coord_cart_neg, cell = self.sc)
                    crystalneg.center_atoms_around_atom(0,coord_cart=crystalneg.rcar,cell=crystalneg.cellvec)
                    #jprint "pos:",crystalpos.rcar
                    #print "neg:",crystalneg.rcar
                    #print "posvec:",crystalpos.rcar[atpos]
                    #print "negvec:",crystalneg.rcar[atneg]
                    posvec = crystalpos.rcar[atpos]
                    negvec = crystalneg.rcar[atneg]



                    #posvec = self.p[idx,atpos]-self.p[idx,0]
                    ##print "kk:",self.p[idx,atneg],\
                    #        #np.array([self.sc[0,0],self.sc[0,0],0.0]),self.p[idx,0]
                    #if x == 1 and contr == 'lon':
                    #    abziehen = np.array([self.sc[0,0],self.sc[0,0],0.0])
                    #if x == 2 and contr == 'lon':
                    #    abziehen = np.array([self.sc[0,0],0.0,0.0])
                    #if x == 1 and contr == 'lon' and self.struct == 'bcc':
                    #    abziehen = np.array([self.sc[0,0],self.sc[0,0],self.sc[0,0]])
                    #if x == 1 and contr in ti:
                    #    abziehen = np.array([0.0,self.sc[0,0],0.0])
                    #if x == 3 and contr in 'lon':
                    #    abziehen = np.array([self.sc[0,0],self.sc[0,0],self.sc[0,0]])

                    #if contr == 'tox' or contr == 'toy' or contr == 'toz':
                    #    abziehen = np.array([0.0,0.0,0.0])


                    #negvec = self.p[idx,atneg]-abziehen-self.p[idx,0]
                    #if x == 1 and contr in ti:
                    #    posvec = negvec

                    #if x == 1 and contr == 'lon' and quer == True and negside == True: #np.linalg.norm(self.p[idx,0]) > 5.0:
                    #    abziehen = np.array([self.sc[0,0],self.sc[0,0],0.0])
                    #    posvec = self.dvec[idx]-abziehen-self.p[idx,atpos]
                    #    negvec = self.p[idx,atpos]+(self.dvec[idx]-abziehen)

                    #if x == 1 and contr in ti and quer == True and negside == True: #np.linalg.norm(self.p[idx,0]) > 5.0:
                    #    abziehen = np.array([self.sc[0,0],self.sc[0,0],0.0])
                    #    posvec = self.dvec[idx]-abziehen-self.p[idx,atpos]
                    #    posvec = self.p[idx,atpos]+(self.dvec[idx]-abziehen)
                    #    v0 = self.dvec[idx]-abziehen
                    #    v1 = self.p[idx,atpos]-np.array([0.0,self.sc[0,0],0.0])
                    #    print "v0:",v0
                    #    print "v1:",v1
                    #    posvec = v0 - v1
                    #    negvec = posvec

                    #    #posvec = np.array([0.0,0.0,0.0])
                    #if x == 1 and self.p[idx,0][0] > 2.0: #self.p[idx,0]: [ 10.79   0.     0.  ]
                    #    pass
                    #    #posvec = self.p[idx,0] -
                    #    if x == 1 and self.p[idx,0][1] > 2.0: #self.p[idx,0]: [ 10.79   10.79.     0.  ]  quer auslenkungA
                    #        pass

                    ## fuer den fall dass wir negative auslenkungen mitgesampled haben:
                    #if self.dvec[idx,0] < 0:
                    #    #if self.p[idx,atneg] > 2.0:
                    #    atpos_ = self.p[idx,atneg] - np.array([self.sc[0,0],self.sc[0,0],0.0])
                    #    p0 = self.p[idx,0] - np.array([self.sc[0,0],0.0,0.0])
                    #    if self.dvec[idx,1] < 0:
                    #        p0 = self.p[idx,0] - np.array([self.sc[0,0],self.sc[0,0],0.0])
                    #    posvec = p0 - atpos_
                    #    negvec = p0 - self.p[idx,atpos]
                    #    if contr in toti:
                    #        posvec = self.p[idx,atneg] - p0
                    #    print "self.p[idx,atneg]:",self.p[idx,atneg]
                    #    print "atpos_:",atpos_
                    #    print "p0:",p0
                    #    print "posvec:",posvec


                    ###########################################################
                    # BEDINGUNGSHOW
                    ###########################################################
                    bedingungshow = False
                    if idx == 0 or idx == 1 or idx == 2 or np.linalg.norm(self.p[idx,0]) == 0.3 or np.linalg.norm(self.p[idx,0]) == 1.0 or idx == len(self.dvec)-1:
                        bedingungshow = True
                    if idx == 0 or idx == len(self.dvec)-1:
                        bedingungshow = True
                    bedingungshow = False


                    if bedingungshow:
                        #print "idx:",idx,"self.p[idx,0]:",self.p[idx,0],"atpos:",atpos,"self.p[idx,atpos:",self.p[idx,atpos],"\tabziehen:",abziehen,"posvec:",posvec\
                        #        ,"|posvec|:",np.linalg.norm(posvec)
                        #print "idx:",idx,"self.p[idx,0]:",self.p[idx,0],"atneg:",atneg,"self.p[idx,atneg:",self.p[idx,atneg],"\tabziehen:",abziehen,"negvec:",negvec\
                        #        ,"|negvec|:",np.linalg.norm(negvec)
                        stratpos = str(atpos)
                        stratneg = str(atneg)
                        if len(stratpos) == 2: stratpos = " "+stratpos
                        if len(stratneg) == 2: stratneg = " "+stratneg
                        strpixpos = self.p[idx,atpos]
                        strpixneg = self.p[idx,atneg]
                        if len(strpixpos) > len(strpixneg):
                            strpixneg = strpixneg+" "*len(strpixpos)-len(strpixneg)
                        if len(strpixneg) > len(strpixpos):
                            strpixpos = strpixpos+" "*len(strpixneg)-len(strpixpos)

                        print utils.printred("DISP:"+str("")+"  LONGPART:"+str(self.dvec[idx]))
                        print "idx:",idx,"self.p[idx,0]:",self.p[idx,0],"atpos:",stratpos,"self.p[idx,atpos:",strpixpos,"posvec:",posvec\
                                ,"|posvec|:",np.linalg.norm(posvec),"force"+stratpos+":",self.f[idx][atpos]
                        print "idx:",idx,"self.p[idx,0]:",self.p[idx,0],"atneg:",stratneg,"self.p[idx,atneg:",strpixpos,"negvec:",negvec\
                                ,"|negvec|:",np.linalg.norm(negvec),"force"+stratneg+":",self.f[idx][atneg]
                        #print "coord_cart_pos:"
                        #print coord_cart_pos
                        #print "coord_cart_neg:"
                        #print coord_cart_neg
                        #print "crystalpos.rcar:--------------------"
                        #print crystalpos.rcar
                        #print "crystalpos:--------------------fin"
                        #print "self.sc:",self.sc
                        #print "crystalneg:--------------------"
                        #print crystalneg.rcar
                        #print "crystalneg:--------------------fin"
                    if self.verbose:
                        print "neg:",self.p[idx,atneg],abziehen,self.p[idx,0]
                        print self.dstring[idx],"pos:",posvec,np.linalg.norm(posvec),\
                                "f:",self.f[idx,atpos]
                        print self.dstring[idx],"neg:",negvec,np.linalg.norm(negvec),\
                                "f:",self.f[idx,atneg]

                    self.funcneg[idx,0] = np.linalg.norm(posvecall[idx])
                    self.funcpos[idx,0] = np.linalg.norm(negvecall[idx])
                    #self.funcnegquermagnitude[idx,0] = np.linalg.norm(posvecall[idx])
                    #self.funcposquermagnitude[idx,0] = np.linalg.norm(negvecall[idx])
                    #self.funcnegquermagnitudecoordtrans[idx,0] = np.linalg.norm(posvecall[idx])
                    #self.funcposquermagnitudecoordtrans[idx,0] = np.linalg.norm(negvecall[idx])

                    if x == 1 or x == 2:
                        self.funcneg[idx,1] = -np.linalg.norm(self.f[idx,atpos])  # - zeichen da repulsive kraft
                        self.funcpos[idx,1] = np.linalg.norm(self.f[idx,atneg])   # + bleibt da attraktive kraft
                    if x == 3:
                        self.funcneg[idx,1] = np.linalg.norm(self.f[idx,atpos])  # - zeichen da repulsive kraft
                        self.funcpos[idx,1] = -np.linalg.norm(self.f[idx,atneg])   # + bleibt da attraktive kraft

                    #if x == 1 and quer == True and negside == True: #np.linalg.norm(self.p[idx,0]) > 5.0:
                    #    if x == 1 or x == 2:
                    #        self.funcneg[idx,1] = np.linalg.norm(self.f[idx,atpos])  # - zeichen da repulsive kraft
                    #        self.funcpos[idx,1] = -np.linalg.norm(self.f[idx,atneg])   # + bleibt da attraktive kraft
                    #if x == 1 and contr in ti and quer == True and negside == True: #np.linalg.norm(self.p[idx,0]) > 5.0:
                    #    self.funcneg[idx,1] = np.linalg.norm(v0)  # - zeichen da repulsive kraft
                    #    self.funcpos[idx,1] = -np.linalg.norm(v0)   # + bleibt da attraktive kraft

                    if self.dvec[idx,0] < 0:
                        if contr == 'lon':
                            self.funcneg[idx,1] =  np.linalg.norm(self.f[idx,atpos])  # - zeichen da repulsive kraft
                            self.funcpos[idx,1] = -np.linalg.norm(self.f[idx,atneg])   # + bleibt da attraktive kraft
                        if contr in toti:
                            self.funcneg[idx,0] = -np.linalg.norm(posvecall[idx])
                            self.funcpos[idx,0] = np.linalg.norm(negvecall[idx])
                    #        self.funcneg[idx,1] = -np.linalg.norm(self.f[idx,atneg])  # - zeichen da repulsive kraft
                    #        self.funcpos[idx,1] = np.linalg.norm(self.f[idx,atpos])   # + bleibt da attraktive kraft


                    if bedingungshow:
                        print "    f1(kurze seite):self.f[idx,atpos]:",self.f[idx,atpos],"|self.f[idx,atpos]|:",np.linalg.norm(self.f[idx,atpos]),"--> self.funcneg[idx]:",self.funcneg[idx]
                        print "    f2(lange seite):self.f[idx,atneg]:",self.f[idx,atneg],"|self.f[idx,atneg]|:",np.linalg.norm(self.f[idx,atneg]),"--> self.funcneg[idx]:",self.funcpos[idx]
                        print " "

                    ########################################################################################
                    ########################################################################################
                    ########################################################################################
                    ## CONTRIBUTINON TO TI
                    ########################################################################################
                    ########################################################################################
                    ########################################################################################
                    if contr in toti:
                        # for to{x,y,z}/ti{x,y,z} we want now to have here the
                        #   lon_{1,2}nn_neg_rlv_0.3_mc1_fit_mc1_xxxCOEFSxxxx
                        #   lon_{1,2}nn_pos_rlv_0.3_mc1_fit_mc1_xxxCOEFSxxxx (NOT)
                        #   FROM THE QUER FOLDER
                        #def longreffolder(
                        if x == 1:
                        #if xdir == True and x == 1:
                            if self.struct == 'fcc':
                                longreffolder = replace_right(os.path.abspath(os.getcwd()),"xdir","quer",1)
                                #longreffolder = replace_right(os.path.abspath(os.getcwd()),"xdir","xdir",1)
                            if self.struct == 'bcc':
                                longreffolder = replace_right(os.path.abspath(os.getcwd()),"xdir","q111",1)
                        #if xdir == True and x == 2:
                        if x == 2:
                            longreffolder = os.getcwd()

                        if type(longreffolder) == bool:
                            sys.exit("longreffolder not found, TYPE bool")
                        if os.path.isdir(longreffolder) != True:
                            sys.exit(longreffolder+" not found")

                        #print "longreffolder:",longreffolder

                        ##################################################################
                        # here we need a module which looks for the longitudinal
                        # reference ( for tox_1nn and for tox_2nn we need the longitudinal
                        # reference), gets the parametrization (morse,mc1,polynomial)
                        # and substracts this force from the current atom
                        ##################################################################
                        # wir sollten hier nicht nur nn_neg sondern ganz nn nehmen evtl.
                        # naja evtl. ist 0.3 doch besser
                        def getlongforce(longreffolder,x,posvec,tito=False,dispdir=False,verbose=False,nnxdist=False,posvecall=False):
                            '''
                            - longreffolder is the folder where it is searchd for
                            the long refence
                            - x is the shell it is looked for (e.g. lon_2nn) x=2
                            '''
                            # we will usually take the accurately parametrized part
                            # in case of 1NN tox berechnung:
                            # in x displacement the longvec will always just be
                            # attractive (never repulsive) --> therefore pos
                            # since vector is longer than equilibrium vector
                            if type(dispdir) == bool:
                                sys.exit("dispdir is bool")
                            if len(dispdir) != 3:
                                sys.exit("len dispdir != 3")
                            xdir, quer, q111 = dispdir

                            to = [ 'tox', 'toy', 'toz' ]
                            ti = [ 'tix', 'tiy', 'tiz' ]
                            if type(tito) == bool:
                                sys.exit("tito is bool")
                            if tito in ti or tito in to:
                                pass
                            else:
                                sys.exit("tito not known")
                            if tito in to:  # here we are only interested in the
                                            # attractive part since d(long) > d1NN
                                sided = '0.35'
                            if tito in ti:  # here we are only interested in the
                                            # attractive part since d(long) > d1NN
                                sided = '0.25' # reicht locker bei jetzigen auslenkungen
                                # lon_1nn_pos_mc1_fit_mc1_0.442778_1.039120_2.920351_0.801952_-0.23830

                            if xdir == True and tito in ti:
                                sided = '0.35'  # macht bei hohen d's "weniger" feherl
                            if type(nnxdist) == False:
                                sys.exit("nnxdist missing")
                            allverh =  np.array([ np.linalg.norm(j)/nnxdist for j in posvecall ])
                            allverhgetmax = abs(allverh.max()-1.0)
                            allverhgetmin = abs(allverh.max()-1.0)
                            allverhget = allverhgetmax
                            if allverhgetmax > allverhgetmax:
                                allverhget = allverhgetmin

                            #print "nnx:",nnxdist,"posvec:",posvec,np.linalg.norm(posvec),"||| VERH:",np.linalg.norm(posvec)/nnxdist,"|| VERHGET:",allverhget
                            if np.linalg.norm(posvec) >= nnxdist:
                                side = "pos"
                                sided = '_rlv_0.35'
                            else:
                                side = "neg"
                                sided = '_rlv_0.25'
                            #print "allverhget:",allverhget
                            #if allverhget <= 0.35:
                            #    sided = '_rlv_0.35'
                            #if allverhget < 0.25:
                            #    sided = '_rlv_0.25'
                            #if allverhget > 0.35:
                            #    sided = ''  # this will give us all the available points and the corresponding fit




                            parameters_long_neg_search = longreffolder+\
                                "/nnforces/lon_"+str(x)+\
                                "nn_"+side+sided+"_mc1_fit___[0-9-]*"
                            #if tito in ti:
                            #    parameters_long_neg_search = longreffolder+\
                            #        "/nnforces/lon_"+str(x)+\
                            #        "nn_"+side+"_mc1_fit_mc1_[0-9-]*"
                            #in case of 2NN tox berechnung:
                            parameters_long_neg_searchalt = longreffolder+\
                                "/nnforces/lon_"+shell+\
                                "nn_"+side+"_poly_fit___*"
                            parameters_long_neg_file = glob.glob(parameters_long_neg_search)
                            parameters_long_neg_filealt =\
                            glob.glob(parameters_long_neg_searchalt)
                            len1 = len(parameters_long_neg_file)
                            len2 = len(parameters_long_neg_filealt)
                            parameters_long_neg_filetake = False
                            found = False
                            if len1 == 0 and len2 == 0:
                                print "parameters_long_neg_search",parameters_long_neg_search
                                print "parameters_long_neg_searchalt",parameters_long_neg_searchalt
                                print "parameters_long_neg_file",parameters_long_neg_file
                                print "parameters_long_neg_filealt",parameters_long_neg_filealt
                                sys.exit("reference not found")
                            if len1 == 1 and len2 == 1:
                                if "_poly_" in parameters_long_neg_filealt[0] and "_poly_" not in parameters_long_neg_file[0]:
                                    parameters_long_neg_filetake =\
                                        parameters_long_neg_filealt[0]
                                    #print "yo1",type(parameters_long_neg_filealt)
                                if "_poly_" not in parameters_long_neg_filealt[0] and "_poly_" in parameters_long_neg_file[0]:
                                    parameters_long_neg_filetake =\
                                        parameters_long_neg_file[0]
                                    #print "yo2",type(parameters_long_neg_file)

                            if len1 != 0 and len2 != 0 and parameters_long_neg_filetake == False:
                                print parameters_long_neg_file
                                print parameters_long_neg_filealt
                                if "_poly_" in parameters_long_neg_filealt:
                                    print "yo1",type(parameters_long_neg_file)
                                print "1"
                                if "_poly_" in parameters_long_neg_file:
                                    print "yo2",type(parameters_long_neg_file)
                                print "2"
                                sys.exit("two references found!?")
                            if len1 != 0 and len2 != 0 and parameters_long_neg_filetake == False:
                                print parameters_long_neg_file
                                print parameters_long_neg_filealt
                                sys.exit("two references found!?")
                            if len1 == 0 and len2 == 0 and parameters_long_neg_filetake == False:
                                if len2 != 1: sys.exit("len2 is not 1")
                                parameters_long_neg_filetake =\
                                        parameters_long_neg_filealt[0]
                            if len1 != 0 and len2 == 0 and parameters_long_neg_filetake == False:
                                #print(parameters_long_neg_file)
                                #print(parameters_long_neg_filealt)
                                if len1 != 1: sys.exit("len1 is not 1")
                                parameters_long_neg_filetake = parameters_long_neg_file[0]
                            if verbose:
                                print "file:",parameters_long_neg_filetake
                            if parameters_long_neg_filetake == False:
                                sys.exit( \
                                        "parameters_long_neg_filetak not found")
                            parameters_long_neg = False

                            if "mc1" in os.path.basename(parameters_long_neg_filetake):
                                #if tito in ti:  # tix
                                #    parameters_long_neg_str = \
                                #    parameters_long_neg_filetake.\
                                #    split("nn_"+side+\
                                #    "_mc1_fit_mc1_")[1]
                                #    parameters_long_neg =\
                                #        pot_energystring_to_list(parameters_long_neg_str)
                                #else:  # tox
                                    parameters_long_neg_str = \
                                    parameters_long_neg_filetake.\
                                    split("nn_"+side+sided+\
                                    "_mc1_fit___")[1]
                                    parameters_long_neg =\
                                            pot_energy.string_to_list(parameters_long_neg_str)

                            if "poly" in os.path.basename(parameters_long_neg_filetake):
                                parameters_long_neg_str = \
                                parameters_long_neg_filetake.\
                                split("order_")[1]
                                #print "1;",parameters_long_neg_str
                                #print "2;",pot_energy.string_to_list(parameters_long_neg_str)
                                parameters_long_neg =\
                                        pot_energy.string_to_list(parameters_long_neg_str)
                            #print 'parameters:',parameters_long_neg
                            if parameters_long_neg == False:
                                sys.exit("parameters_long_neg not found")

                            forcelong = False
                            #print "||",parameters_long_neg
                            #print "|||",np.linalg.norm(-posvec)
                            if "mc1" in os.path.basename(parameters_long_neg_filetake):
                                forcelong = getforcepot(-posvec,'mc1',parameters_long_neg)
                            if "poly" in os.path.basename(parameters_long_neg_filetake):
                                #sys.exit("POLY!")
                                #forcelong = getforcepot(-posvec,'mc1',parameters_long_neg)
                                e,forcelong = pot_energy.getefvec(-posvec,parameters_long_neg,pot = False)
                            if type(forcelong) == bool:
                                sys.exit("forcelong not found")
                            return forcelong



                        dispdir = [ xdir, quer, q111 ]
                        if bedingungshow:
                            print utils.printyellow("TO - TI - PART:")
                            print "dispdir:",dispdir

                        # for tox posvec will be enough
                        forcelong = getlongforce(longreffolder,x,posvec,contr,dispdir,verbose=bedingungshow,nnxdist=self.nnxdist,posvecall=posvecall)
                        forcelongneg = getlongforce(longreffolder,x,negvec,contr,dispdir,verbose=bedingungshow,nnxdist=self.nnxdist,posvecall=posvecall)


                        if bedingungshow:
                            print "posvec    ",posvec,"norm:",np.linalg.norm(posvecall[idx])
                            print "negvec    ",negvec,"norm:",np.linalg.norm(negvecall[idx])
                            print "force     ",self.f[idx,atneg]
                            print "forcelong   >",forcelong
                            print "forcelongneg>",forcelongneg


                        #print "pos>>:",posvec
                        #print "neg>>:",negvec
                        # der posvec/negvec sind immer da um die kraft fuer die longitudinale komponente zu bekommen, von daher muessen diese immer zwischen 1.5 udn 3.5 sein
                        if x == 1 and np.linalg.norm(posvec) > 5.6:    # posvec has always to be smaller then equilibrium lattice constant
                            sys.exit("posvec > 5.6:"+str(posvec)+" "+str(np.linalg.norm(posvec)))

                        if x == 1 and np.linalg.norm(posvec) < 1.5:
                            sys.exit("posvec < 1.5:"+str(posvec)+" "+str(np.linalg.norm(posvec)))
                        if x == 1 and np.linalg.norm(negvec) < 1.5:
                            sys.exit("negvec < 1.5:"+str(negvec)+" "+str(np.linalg.norm(negvec)))
                        if x == 1 and np.linalg.norm(negvec) > 5.6:
                            sys.exit("negvec > 5.6:"+str(negvec)+" "+str(np.linalg.norm(negvec)))


                            # in case of tox (2NN)  we need to get the forcelong from
                            # the polyfit! (since lon2NN was parametrized with a polynom)

                        #print "f:",self.f[idx,atneg]
                        #print 'fcl:',forcelong
                        toxrest = self.f[idx,atneg] - forcelong
                        if bedingungshow:
                            print "toxrest:  ",toxrest

                        if bedingungshow:
                            print "toxrestNEW",toxrest


                        # hier fuer tox erstmal nur die x komponente
                        if contr in to or contr == 'lon':
                            if contr == 'tox':takeidx = 0
                            if contr == 'toy':takeidx = 1
                            if contr == 'toz':takeidx = 2
                            self.funcneg[idx,0] =  -posvec[0]
                            self.funcpos[idx,0] =   negvec[0]
                            self.funcneg[idx,1] =  toxrest[takeidx]
                            self.funcpos[idx,1] = -toxrest[takeidx]
                            #    print "selfd < 0:"
                            #    if contr == 'lon':
                            #        print "selfd < 0:lon"
                            #        self.funcneg[idx,1] = -toxrest[takeidx]
                            #        self.funcpos[idx,1] = -toxrest[takeidx]
                                #if contr == 'tox':
                                #    self.funcneg[idx,0] =  -posvec[0]
                                #    self.funcpos[idx,0] =  -negvec[0]
                                #if contr == 'tox':
                                #    self.funcneg[idx,0] =  -posvec[0]
                                #    self.funcpos[idx,0] =  -negvec[0]
                        if contr in ti:
                            if contr == 'tix':takeidx = 0
                            if contr == 'tiy':takeidx = 1
                            if contr == 'tiz':takeidx = 2

                        if xdir == True and contr == 'toy' or contr == 'toz':
                            if self.dvec[idx,0] >= 0:
                                self.funcneg[idx,0] =  posvec[0]
                                self.funcpos[idx,0] =  -negvec[0]
                                self.funcneg[idx,1] =  -toxrest[takeidx]
                                self.funcpos[idx,1] =  toxrest[takeidx]
                            if self.dvec[idx,0] < 0:
                                self.funcneg[idx,0] =  -posvec[0]
                                self.funcpos[idx,0] =  negvec[0]
                                self.funcneg[idx,1] =  -toxrest[takeidx]
                                self.funcpos[idx,1] =  toxrest[takeidx]

                        if xdir == True and contr == 'tix' or contr == 'tiy':
                            if self.dvec[idx,0] >= 0:
                                self.funcneg[idx,0] =  self.dvec[idx][0]
                                self.funcpos[idx,0] =  self.dvec[idx][0]
                                self.funcneg[idx,1] =  toxrest[takeidx]
                                self.funcpos[idx,1] =  toxrest[takeidx]
                            if self.dvec[idx,0] < 0:
                                self.funcneg[idx,0] =  self.dvec[idx][0]
                                self.funcpos[idx,0] =  self.dvec[idx][0]
                                self.funcneg[idx,1] =  toxrest[takeidx]
                                self.funcpos[idx,1] =  toxrest[takeidx]

                        if quer == True and contr == 'tix' or contr == 'tiy':
                            if self.dvec[idx,0] >= 0:
                                #self.funcneg[idx,0] =  self.dvec[idx][0]
                                #self.funcpos[idx,0] =  self.dvec[idx][0]
                                self.funcneg[idx,0] = math.copysign(np.linalg.norm([self.dvec[idx][0],self.dvec[idx][1],0.0]),self.dvec[idx][0])
                                self.funcpos[idx,0] = math.copysign(np.linalg.norm([self.dvec[idx][0],self.dvec[idx][1],0.0]),self.dvec[idx][0])
                                self.funcneg[idx,1] =  toxrest[takeidx]
                                self.funcpos[idx,1] =  toxrest[takeidx]

                                #self.funcnegquermagnitude[idx,0] = np.linalg.norm(self.dvec[idx])
                                #self.funcposquermagnitude[idx,0] = np.linalg.norm(self.dvec[idx])
                                #self.funcnegquermagnitude[idx,1] = self.funcneg[idx,1]
                                #self.funcposquermagnitude[idx,1] = self.funcpos[idx,1]



                            if self.dvec[idx,0] < 0:
                                #self.funcneg[idx,0] =  self.dvec[idx][0]
                                #self.funcpos[idx,0] =  self.dvec[idx][0]
                                self.funcneg[idx,0] = math.copysign(np.linalg.norm([self.dvec[idx][0],self.dvec[idx][1],0.0]),self.dvec[idx][0])
                                self.funcpos[idx,0] = math.copysign(np.linalg.norm([self.dvec[idx][0],self.dvec[idx][1],0.0]),self.dvec[idx][0])
                                self.funcneg[idx,1] =  toxrest[takeidx]
                                self.funcpos[idx,1] =  toxrest[takeidx]

                                #self.funcnegquermagnitude[idx,0] = np.linalg.norm(self.dvec[idx])
                                #self.funcposquermagnitude[idx,0] = np.linalg.norm(self.dvec[idx])
                                #self.funcnegquermagnitude[idx,1] = self.funcneg[idx,1]
                                #self.funcposquermagnitude[idx,1] = self.funcpos[idx,1]



                        #if contr in ti:
                        #    # noch nicht ob es besser ist das vom vollen vektor zu bekommen
                        #    # oder einfach nur die x/y komponente seperat zu nehmen
                        #    if contr == 'tix':takeidx = 0
                        #    if contr == 'tiy':takeidx = 1
                        #    if contr == 'tiz':takeidx = 2
                        #    self.funcneg[idx,0] =  -self.p[idx,0][0]
                        #    self.funcpos[idx,0] =  self.p[idx,0][0]


                        #    if xdir == True and contr == 'tix':
                        #        longvec = posvec
                        #        vec0 = np.array([-posvec[1],posvec[1],0.0])
                        #        print "longvec:",longvec
                        #        print "vec0:",vec0
                        #        tvecout = utils.project_vector(utils.reject_vector(longvec,vec0),np.array([1.0,1.0,0.0]))
                        #        print "tvecout:",tvecout
                        #        #self.funcneg[idx,0] =  -self.p[idx,0][0]
                        #        #self.funcpos[idx,0] =  self.p[idx,0][0]
                        #        self.funcneg[idx,0] =  -np.linalg.norm(tvecout)
                        #        self.funcpos[idx,0] =  np.linalg.norm(tvecout)
                        #        self.funcneg[idx,1] =  -toxrest[takeidx]
                        #        self.funcpos[idx,1] =  toxrest[takeidx]

                        #    if xdir == True and contr == 'tiy':
                        #        longvec = posvec
                        #        vec0 = np.array([-posvec[1],posvec[1],0.0])
                        #        print "longvec:",longvec
                        #        print "vec0:",vec0
                        #        tvecout = utils.project_vector(utils.reject_vector(longvec,vec0),np.array([1.0,1.0,0.0]))
                        #        print "tvecout:",tvecout
                        #        #self.funcneg[idx,0] =  -self.p[idx,0][0]
                        #        #self.funcpos[idx,0] =  self.p[idx,0][0]
                        #        self.funcneg[idx,0] =  -np.linalg.norm(tvecout)
                        #        self.funcpos[idx,0] =  np.linalg.norm(tvecout)
                        #        self.funcneg[idx,1] = -toxrest[takeidx]
                        #        self.funcpos[idx,1] =  toxrest[takeidx]


                        #    if quer == True and contr == 'tix':
                        #        #self.funcneg[idx,0] =  -self.p[idx,0][0]
                        #        #self.funcpos[idx,0] =  self.p[idx,0][0]
                        #        self.funcneg[idx,0] =  0.0 #-np.linalg.norm(self.p[idx,0])
                        #        self.funcpos[idx,0] =  np.linalg.norm(self.p[idx,0])
                        #        self.funcneg[idx,1] = 0.0 #-toxrest[takeidx]
                        #        self.funcpos[idx,1] =  toxrest[takeidx]


                        #    if quer == True and contr == 'tiy':
                        #        #self.funcneg[idx,0] =  -self.p[idx,0][0]
                        #        #self.funcpos[idx,0] =  self.p[idx,0][0]
                        #        self.funcneg[idx,0] =  0.0 #-np.linalg.norm(self.p[idx,0])
                        #        self.funcpos[idx,0] =  np.linalg.norm(self.p[idx,0])
                        #        self.funcneg[idx,1] =  0.0 #-toxrest[takeidx]
                        #        self.funcpos[idx,1] = toxrest[takeidx]
                        #        # mind: toxrest: [-0.062368 -0.024493 -0.      ] on
                        #        # atom 87 is attractive in x and repulsive in y!!!
                        #        #
                        #    if quer == True and contr == 'tix' and negside == True:
                        #        self.funcneg[idx,0] =  0.0 #-np.linalg.norm(self.p[idx,0])
                        #        self.funcpos[idx,0] =  np.linalg.norm(v0)
                        #        self.funcneg[idx,1] = 0.0 #-toxrest[takeidx]
                        #        self.funcpos[idx,1] =  toxrest[takeidx]
                        #    if quer == True and contr == 'tiy':
                        #        self.funcneg[idx,0] =  0.0 #-np.linalg.norm(self.p[idx,0])
                        #        self.funcpos[idx,0] =  np.linalg.norm(v0)
                        #        self.funcneg[idx,1] =  0.0 #-toxrest[takeidx]
                        #        self.funcpos[idx,1] = toxrest[takeidx]


                        if bedingungshow:
                            print "funcpos[idx]>>:",self.funcpos[idx]
                            print "funcneg[idx]>>:",self.funcneg[idx]
                            print "-----"
                            print ""

                # here: in case we do have dvec:
                # bring vectors in right order
                if type(self.DOScut) != bool: #self.DOScut is a numpy array
                    self.funcneg = utils.cut_function_at_DOS(self.funcneg,self.DOScut)
                    self.funcpos = utils.cut_function_at_DOS(self.funcpos,self.DOScut)

                self.funcall = np.concatenate((self.funcneg,self.funcpos))
                if contr == 'lon':
                    zeroat = self.nnxdist
                else:  # 'to{x,y,z}','ti{x,y,z}'
                    zeroat = 0.0
                self.funcall = np.concatenate((self.funcall,np.array([[zeroat,0.0]])))
                #print "sfa: ----------------------"
                #print self.funcall
                #print "sfa: ----------------------"

                self.funcall = self.funcall[self.funcall[:,0].argsort()]
                self.funcneg = np.concatenate((self.funcneg,np.array([[zeroat,0.0]])))
                self.funcpos = np.concatenate((self.funcpos,np.array([[zeroat,0.0]])))
                self.funcneg = self.funcneg[self.funcneg[:,0].argsort()]
                self.funcpos = self.funcpos[self.funcpos[:,0].argsort()]

                if contr == 'lon':
                    self.funcpos = self.funcpos[self.funcpos[:,0] >= self.nnxdist]
                    self.funcneg = self.funcneg[self.funcneg[:,0] <= self.nnxdist]
                #print "self.funcneg:"
                #print self.funcneg
                #print "self.funcpos:"
                #print self.funcpos



                #forlinfit = np.array([self.funcpos[1],self.funcpos[0],self.funcneg[-2]])
                if self.verbose:
                    print "--"
                    print self.funcpos[0]
                    print self.funcpos[1]
                    print self.funcneg[-2]

                print utils.printyellow("################# "+contr+": ##################")
                print self.funcall[:4]
                print self.funcall[-4:]
                print ""


                ###################################################
                ## fit all forces
                ###################################################
                for funcalld in funcalldall:   #     0.2 oder 0.3

                    print utils.printgreen("################# funcalld: "+str(funcalld)+" ########################")
                    self.funcalld = funcalld
                    dstr = str(self.funcalld)
                    # erst an dieser stelle wird das d interessant
                    # get min and max d
                    self.funcallmax = self.nnxdist+self.funcalld*self.nnxdist
                    self.funcallmin = self.nnxdist-self.funcalld*self.nnxdist

                    # get rlv region
                    self.funcnegrlv = \
                            self.funcneg[self.funcneg[:,0]>self.funcallmin]
                    self.funcposrlv = \
                            self.funcpos[self.funcpos[:,0]<self.funcallmax]
                    self.funcallrlv = \
                            np.concatenate((self.funcnegrlv,self.funcposrlv))
                    self.funcallrlv = \
                            self.funcallrlv[self.funcallrlv[:,0].argsort()]

                    self.funcallrlvallpos = \
                            np.concatenate((self.funcnegrlv,self.funcpos))
                    self.funcallrlvallpos = \
                            self.funcallrlvallpos[self.funcallrlvallpos[:,0].argsort()]

                    # save vectors
                    #if self.verbose:
                    print "saving:"
                    print  self.fitfolder+contr+"_"+shell+"nn_all"
                    print  self.fitfolder+contr+"_"+shell+"nn_pos"
                    print  self.fitfolder+contr+"_"+shell+"nn_neg"
                    if type(self.DOScut) == bool:
                        print  self.fitfolder+contr+"_"+shell+"nn_pos_rlv_"+dstr
                        print  self.fitfolder+contr+"_"+shell+"nn_neg_rlv_"+dstr

                    np.savetxt(self.fitfolder+contr+"_"+shell+"nn_all",self.funcall,fmt="%.6f")
                    np.savetxt(self.fitfolder+contr+"_"+shell+"nn_all_shiftedto0",np.transpose([self.funcall[:,0]-self.nnxdist,self.funcall[:,1]]),fmt="%.6f")

                    if quer == True and contr in 'tiy':  # at this point we usually already do have tix
                        tix = np.loadtxt(self.fitfolder+"tix"+"_"+shell+"nn_all")
                        tiy = np.loadtxt(self.fitfolder+"tiy"+"_"+shell+"nn_all")
                        #print "tix:"
                        #print tix
                        #print "tiy:"
                        #print tiy
                        out = np.zeros((tix.shape[0],3))
                        #print "coordinate transformation for plotting quer function"
                        for outidx,outline in enumerate(out):
                            out[outidx][0] = tix[outidx][0]
                            #print  tix[outidx],tiy[outidx],utils.coord_transform_to_quer(np.array([tix[outidx][1],tiy[outidx][1],0.0]))
                            coordtransformed = utils.coord_transform_to_quer(np.array([tix[outidx][1],tiy[outidx][1],0.0]))
                            #print "coordtransformed:",coordtransformed
                            out[outidx][1] = coordtransformed[0]
                            out[outidx][2] = coordtransformed[1]
                        quermagnitude_coordstransformed_x = out[:,:2]
                        quermagnitude_coordstransformed_y = out[:,[0,2]]

                        np.savetxt(self.fitfolder+'tix'+"_"+shell+"nn_all_coordstransformed_quer",quermagnitude_coordstransformed_x,fmt="%.6f")
                        np.savetxt(self.fitfolder+'tiy'+"_"+shell+"nn_all_coordstransformed_quer",quermagnitude_coordstransformed_y,fmt="%.6f")
                        # let's now parametrize this functions
                        polyfit(
                            foldername=self.fitfolder,
                            filename='tix'+"_"+shell+"nn_all_coordstransformed_quer_poly",
                                    zeroat=0.0,
                                    data=quermagnitude_coordstransformed_x)
                        polyfit(
                            foldername=self.fitfolder,
                            filename='tiy'+"_"+shell+"nn_all_coordstransformed_quer_poly",
                                    zeroat=0.0,
                                    data=quermagnitude_coordstransformed_y)



                        ################################################################################################################################
                        # Now we want to get the difference between the xdisplacement and the querdisplacemetn to determine the ti parallel part
                        ################################################################################################################################
                        # go thround every xdir-displacement and get corresponding quer force
                        #for i in self.dvec:  #his is ment to be the dvec in x-dir which goes up to 1.6
                        #for outidx,outline in enumerate(out):
                        #    vec0 = np.array([ 2.065, -2.065,  0.   ])
                        #    vecs = np.array([1.0,1.0,0.0])
                        #    longvec = np.array([-2.065+i[0],2.065,0.0])
                        #    print i,longvec,utils.anyvec_to_inplane_senkr_parallel(longvec,vec0,vecs)
                        #    quervec = utils.anyvec_to_inplane_senkr_parallel()


                    if contr == 'lon':
                        np.savetxt(self.fitfolder+contr+"_"+shell+"nn_pos",self.funcpos,fmt="%.6f")
                        np.savetxt(self.fitfolder+contr+"_"+shell+"nn_neg",self.funcneg,fmt="%.6f")
                        if type(self.DOScut) == bool:
                            np.savetxt(self.fitfolder+contr+"_"+shell+"nn_pos_rlv_"+dstr,self.funcposrlv,fmt="%.6f")
                            np.savetxt(self.fitfolder+contr+"_"+shell+"nn_neg_rlv_"+dstr,self.funcnegrlv,fmt="%.6f")
                            np.savetxt(self.fitfolder+contr+"_"+shell+"nn_all_rlv_"+dstr,self.funcallrlv,fmt="%.6f")
                            np.savetxt(self.fitfolder+contr+"_"+shell+"nn_all_rlv_"+dstr+"_allpos",self.funcallrlvallpos,fmt="%.6f")

                    #####################################################################################################
                    # make fit (it would be best to do this seperately for the left and for the right side
                    #####################################################################################################
                    # fit long forces
                    #####################################################################################################
                    if x == 1 and contr == 'lon':

                        if type(self.DOScut) == bool:
                            # fit neg rlv  (m, mc1)
                            self.funcnegmorse = get_fit_forces_to_pot(
                            foldername=self.fitfolder,
                            filename=contr+"_"+shell+"nn_neg_rlv_"+dstr+"_mc1",
                                    NN=self.nnxdist,pot = 'mc1',
                                    data=self.funcnegrlv)

                            self.funcnegmorse = get_fit_forces_to_pot(
                            foldername=self.fitfolder,
                            filename=contr+"_"+shell+"nn_neg_rlv_"+dstr+"_morse",
                                    NN=self.nnxdist,pot = 'm',
                                    data=self.funcnegrlv)

                            # fit pos rlv (m, mc1)
                            self.funcposmorse = get_fit_forces_to_pot(
                            foldername=self.fitfolder,
                            filename=contr+"_"+shell+"nn_pos_rlv_"+dstr+"_mc1",
                                    NN=self.nnxdist,pot = 'mc1',
                                    data=self.funcposrlv)


                            # fit all rlv (links und rechts den gleichen bereich)
                            self.funcallmorse = get_fit_forces_to_pot(
                            foldername=self.fitfolder,
                            filename=contr+"_"+shell+"nn_all_rlv_"+dstr+"_morse",
                                    NN=self.nnxdist, pot = 'm',
                                    data=self.funcallrlv)

                            self.funcallmorse = get_fit_forces_to_pot(
                            foldername=self.fitfolder,
                            filename=contr+"_"+shell+"nn_all_rlv_"+dstr+"_mc1",
                                    NN=self.nnxdist, pot = 'mc1',
                                    data=self.funcallrlv)


                            # fit allrvl + all pos on the right side
                            self.funcallmorse = get_fit_forces_to_pot(
                            foldername=self.fitfolder,
                            filename=contr+"_"+shell+"nn_all_rlv_"+dstr+"_allpos_morse",
                                    NN=self.nnxdist, pot = 'm',
                                    data=self.funcallrlvallpos)

                            self.funcallmorse = get_fit_forces_to_pot(
                            foldername=self.fitfolder,
                            filename=contr+"_"+shell+"nn_all_rlv_"+dstr+"_allpos_mc1",
                                    NN=self.nnxdist, pot = 'mc1',
                                    data=self.funcallrlvallpos)


                        # fit pos all
                        self.funcallmorse = get_fit_forces_to_pot(
                        foldername=self.fitfolder,
                        filename=contr+"_"+shell+"nn_pos_mc1",
                                NN=self.nnxdist, pot = 'mc1',
                                data=self.funcpos)

                        self.funcallmorse = get_fit_forces_to_pot(
                        foldername=self.fitfolder,
                        filename=contr+"_"+shell+"nn_pos_morse",
                                NN=self.nnxdist, pot = 'm',
                                data=self.funcpos)

                        # fit neg all
                        self.funcallmorse = get_fit_forces_to_pot(
                        foldername=self.fitfolder,
                        filename=contr+"_"+shell+"nn_neg_mc1",
                                NN=self.nnxdist, pot = 'mc1',
                                data=self.funcneg)



                        # plyfits for the pos part
                        for orderfit in np.arange(1,10):
                            # makes something like lon_1nn_pos_poly9_6_fit___157.32847059439_-253.3149803360_172.60763615111_-64.55258342696_14.303612909803_-1.874831186120_0.1343007378748_-0.004043636776 BUT NOT A CORRESPONDING DELTAFOLDER
                            # here the deltas are saved in deltas but no fit is made afterwards
                            deltadatafilename = polyfit(
                                foldername=self.fitfolder,
                                filename=contr+"_"+shell+"nn_pos",
                                zeroat=zeroat,
                                data=self.funcpos,
                                ordermax=orderfit,
                                verbose2=False
                                )

                        #######################################################
                        # fit all above but for DOScut bereich
                        #######################################################
                        if type(self.DOScut) != bool:
                            # fit neg rlv  (m, mc1)
                            self.funcnegmorse = get_fit_forces_to_pot(
                            foldername=self.fitfolder,
                            filename=contr+"_"+shell+"nn_all_mc1",
                                    NN=self.nnxdist,pot = 'mc1',
                                    data=self.funcall)

                            self.funcnegmorse = get_fit_forces_to_pot(
                            foldername=self.fitfolder,
                            filename=contr+"_"+shell+"nn_all_morse",
                                    NN=self.nnxdist,pot = 'm',
                                    data=self.funcall)


                    else:
                        #####################################################################################################
                        # fit tox forces (da else) ( == immer wenn contribution nicht lon ist )
                        # verstehen nicht wiso hier wider auf lon angespielt wird, sollte hier keinen sinn machen
                        #####################################################################################################
                        if contr == 'lon':
                            sys.exit("hier sollte NIE noch lon sein, ansonsten verstehen ich was nicht; scheint auch der fall zu sein")

                        if contr == 'lon':
                            zeroat = self.nnxdist
                        if contr == 'tox' or contr == 'toy' or contr == 'toz' or contr == 'tix' or contr == 'tiy' or contr == 'tiz':
                            zeroat = 0.0
                        print "zeroat:",zeroat,"self.nnxdist:",self.nnxdist

                        for orderfit in np.arange(1,10):
                            # makes something like lon_1nn_pos_poly9_6_fit___157.32847059439_-253.3149803360_172.60763615111_-64.55258342696_14.303612909803_-1.874831186120_0.1343007378748_-0.004043636776 BUT NOT A CORRESPONDING DELTAFOLDER
                            # here the deltas are saved in deltas but no fit is made afterwards
                            deltadatafilename = polyfit(
                                foldername=self.fitfolder,
                                filename=contr+"_"+shell+"nn_all",
                                zeroat=zeroat,
                                data=self.funcall,
                                ordermax=orderfit,
                                verbose2=False
                                )


                        #if contr == 'lon':
                        #    # will keinen polyfit ueber die ganze range, macht keinen sinn, hat keinen exponenten wie morse
                        #    polyfit(
                        #    foldername=self.fitfolder,
                        #    filename=contr+"_"+shell+"nn_pos",
                        #            zeroat=zeroat,
                        #            data=self.funcpos)

                    if xdir == True and contr in ti and x == 1:  # first shell
                        print ""
                        print "Building ti force component in parallel direction ..."
                        print ""
                        # For tox it is easy since there is "only" one tox direction, therefore 2NN should work well when included 2nn_lon and 2nn_tox
                        #
                        # a1) DONE; get the ture ti forces in x-direction
                        # a2) DONE; get parametrization ti of forces in x-direction (just done above)
                        # b1) DONE; get the true ti forces in quer-direction  (ti{x,y}_1nn_all)
                        # b2) DONE; get parametrization ti of forces in quer-direction ( from quer folder)
                        # c)  DONE; get a function which gives for any longvec (rather tvec) the correct projection on senkr/=quer and parallel (see utils)
                        # d)  DONE; when in quer auslenkung, get forces in x and y direction (hopefully this is ok, but should be only a matter of coordinate transformation)
                        #           correctly one should plot this as a function of magnitude in quer direction; do we save this as a function of x coordinate os as a function of magnitued of disp?
                        #           it is easier to save this as a function of x coordinate then no transformation is necessary
                        # e)  DONE; make a seperate quer kraft for plotting which is as function of magnitude
                        # f)  DONE; make a seperate quer kraft for plotting which is as function of magnitude and the force shows in quer and par direction! (par since the force will have
                        #           a y component)
                        # g)  DONE; get the minvalues and maxvalues to which the parallel plot still does have to be extrapolated
                        # h)  DONE; get the difference x-dir ti{x,y} (a2) (=full force on 87)  minus d) for the correct mesh in e) == parkraft
                        #           example: if xdir auslenkung = 1.271/0/0 we want to substract the force form quer from (0.9192343/0.9192343/0) (make module longvec_quer_par_force)
                        #           therefore x = (1.271/0/0) would be the maximum displacement
                        #           therefore: go thround every xdir-displacement and get corresponding quer force
                        #           |xdir| = 1.271  --> |quer| = 1.3
                        #           |xdir| = 2.065  --> |quer| = 2.92 (==nndist)
                        #           |xdir| = 0.5    --> |quer| = 0.40225220472457851
                        #           --> |xdir| and |quer| are very similar but for large vectors
                        #           !!! IN PRINCIPLE ONE COULD ALTHO THINK TO DEFINE THE FORCE PARAMETRIZED as a function of |xdir| or |quer|; make those equal and project those on par/quer?
                        #           !!! NO THIS DOES NOT MAKE SENSE; Just think of quer auslenkung! There is no parallel part!
                        # i) once we do have the x and y coordinate of the parkraft: transform h) (parkraft) to parbasis (needs coordinate transformation) (once on quer basis once on par basis)
                        #
                        # ?) problem?: the parkraft will only be defined to 0.6 but it should be in principle be defined as far as |quer|. Here there has to be a certain symmetry!? At the parts were we dont have the quer direction but just the pardirection.
                        # parallel part of ti woks full in xdir; going from xdir to quer or par direction reduces forces of par
                        # !! Wenn wir in einer naeherung bleiben wollen welche aehnlich der Harmonischen naeherung ist (ohne winkelabhaengigkeit) dann koennen wir "nur" eine ti-mode
                        # samplen welche senkrecht zur longitudinalen mode ist


                        #
                        # [351]utils.anyvec_to_inplane_senkr_parallel(np.array([(-2.065+1.271),  2.065+1.271,  0.0   ]),np.array([2.065, -2.065,  0.]),np.array([2.0,2.0,0.0]))
                        # Out[351]: (array([ 1.271,  1.271,  0.   ]), array([ 0.,  0.,  0.]))
                        #
                        # [352]utils.anyvec_to_inplane_senkr_parallel(np.array([(-2.065+1.271),  2.065+0.0,  0.0   ]),np.array([2.065, -2.065,  0.]),np.array([2.0,2.0,0.0]))
                        # Out[352]: (array([ 0.918019,  0.918019,  0.      ]), array([ 0.6355, -0.6355,  0.    ]))
                        #
                        # [350]utils.anyvec_to_inplane_senkr_parallel(np.array([(-2.065+1.271),  2.065-1.271,  0.0   ]),np.array([2.065, -2.065,  0.]),np.array([2.0,2.0,0.0]))
                        # Out[350]: (array([ 0.,  0.,  0.]), array([ 1.271, -1.271,  0.   ]))
                        #
                        #
                        # WHEN this is done, the inplane forces can then be calculated
                        #   a) check the quer auslenkungen where there is no parkraft
                        #   b) chekc the xdisp auslenkung where we have senkkraft and parkraft, all the x auslenkungen should now be perfect (for the 1NN).
                        #   c) the quer auslenkungen: check that symmetries are correctly implemented; how well forces are described ..... we will see; probably/hopefully better then without ti forces

                        ############################
                        # a1)
                        ############################
                        tidataxdirxy = np.copy(self.funcall)
                        #print "tidataxy:"
                        #print tidataxy

                        ############################
                        # a2)
                        ############################
                        print "zeroat:",zeroat
                        ti_xdir_coefsrealene,ti_xdir_coefsrealforces,deltas = polyfit(
                                foldername=False,
                                filename=False,
                                zeroat=zeroat,
                                data=tidataxdirxy,
                                verbose2=False)
                        print "ti_xdir_coefsrealene,ti_xdir_coefsrealforces:",ti_xdir_coefsrealene,ti_xdir_coefsrealforces

                        ############################
                        # b1)
                        ############################
                        #if self.xquer == 'x':
                        print "longreffolder:",longreffolder
                        if contr == 'tix':
                            #tidataquerxy = np.loadtxt(longreffolder+self.fitfolder+'/tix_1nn_all')
                            tidataquerxy = np.loadtxt(longreffolder+'/nnforces/tix_1nn_all')
                        if contr == 'tiy':
                            #tidataquerxy = np.loadtxt(longreffolder+self.fitfolder+'/tiy_1nn_all')
                            tidataquerxy = np.loadtxt(longreffolder+'/nnforces/tiy_1nn_all')

                        ############################
                        # b2)
                        ############################
                        print "zeroat:",zeroat
                        ti_quer_coefsrealene,ti_quer_coefsrealforces,deltas = polyfit(
                                foldername=False,
                                filename=False,
                                zeroat=zeroat,
                                data=tidataquerxy,
                                verbose2=False)
                        print "ti_quer_coefsrealene,ti_quer_coefsrealforces:",ti_quer_coefsrealene,ti_quer_coefsrealforces

                        ############################
                        # c) see utils
                        ############################

                        ############################
                        # f) search for: quermagnitude_coordstransformed_y
                        ############################


                        ############################
                        # g) mesh
                        ############################
                        meshmin = tidataxdirxy[:,0].min()
                        meshmax = tidataxdirxy[:,0].max()
                        if tidataquerxy[:,0].min() > meshmin:
                            meshmin = tidataquerxy[:,0].min()
                        if tidataquerxy[:,0].max() < meshmax:
                            meshmax = tidataquerxy[:,0].max()

                        print "min:",meshmin
                        print "max:",meshmax


                        ################################################################################################################################
                        # h) Now we want to get the difference between the xdisplacement and the querdisplacemetn to determine the ti parallel part
                        ################################################################################################################################
                        # go thround every xdir-displacement and get corresponding quer force
                        def longvec_quer_par_force():
                            pass


                        print ""
                        print "for x-dir auslenkung"

                        tiparxy= np.zeros((len(self.dvec),2))
                        for dvecidx,i in enumerate(self.dvec):
                            vec0 = np.array([ 2.065, -2.065,  0.   ])
                            vecs = np.array([1.0,1.0,0.0])
                            longvec = np.array([-2.065+i[0],2.065,0.0])
                            senkr, parallel = utils.anyvec_to_inplane_senkr_parallel(longvec,vec0,vecs)

                            vec0par = np.array([ 2.065, -2.065,  0.   ])
                            vecspar = np.array([1.0,1.0,0.0])
                            longvecpar = np.array([-2.065+i[0],2.065+i[0],0.0])
                            senkrpar, parallelpar = utils.anyvec_to_inplane_senkr_parallel(longvecpar,vec0par,vecspar)

                            # dies wird bei 'tix' fuer die x komponente und bei und bei 'tiy' fuer die y komponente gemacht
                            # f ist nun die kraft aus quer
                            equer,fquer = pot_energy.getef(senkr[0],ti_quer_coefsrealene)
                            exdir,fxdir = pot_energy.getef(i[0],ti_xdir_coefsrealene)
                            #print "i:",i,"longvec:",longvec,"senkr:",senkr,"parallel:",parallel
                            #print "i[0]:",i[0],"senkr[0]:",senkr[0],"fquer",fquer,"i[0]:",i[0],"fxir:",fxdir
                            #[ 1.3  0.   0. ] [-0.765  2.065  0.   ] senkr: [ 0.948587  0.948587  0.      ] parallel: [ 0.65 -0.65  0.  ] senkr[0]: 0.948586572438 querfunktion(senkr[0]) 0.00992614445689
                            # the corresponding force we now need is force of the x displacment
                            dpar = parallel[0]
                            fpar =  fxdir - fquer
                            tiparxy[dvecidx][0] = dpar
                            tiparxy[dvecidx][1] = fpar
                            #print "this should only be plotted up to 1.3, not to 1.6 (this would extrapolate) the quer regin too far which is only defined up to 0.919 \
                            #        (which is 1.3 absolute in quer direction)"
                            #print "senkr[0]",senkr[0],"meshmax:",meshmax,"meshmin:",meshmin
                            if senkr[0] > meshmax+0.05:
                                tiparxy[dvecidx][0] = 0.0
                                tiparxy[dvecidx][1] = 0.0
                            if senkr[0] < meshmin-0.05:
                                tiparxy[dvecidx][0] = 0.0
                                tiparxy[dvecidx][1] = 0.0

                        tiparxy = np.concatenate((tiparxy,np.array([[zeroat,0.0]])))
                        tiparxy = tiparxy[tiparxy[:,0].argsort()]
                        np.savetxt(self.fitfolder+contr+"_"+shell+"nn_all_parallel_f_in_xy",tiparxy,fmt="%.6f")


                        if contr == 'tiy': #ensured that tix does already exist
                            tix = np.loadtxt(self.fitfolder+"tix"+"_"+shell+"nn_all_parallel_f_in_xy")
                            tiy = np.loadtxt(self.fitfolder+"tiy"+"_"+shell+"nn_all_parallel_f_in_xy")
                            #print "tix:"
                            #print tix
                            #print "tiy:"
                            #print tiy
                            out = np.zeros((tix.shape[0],3))
                            #print "coordinate transformation for plotting quer function"
                            for outidx,outline in enumerate(out):
                                out[outidx][0] = tix[outidx][0]
                                #print  tix[outidx],tiy[outidx],utils.coord_transform_to_quer(np.array([tix[outidx][1],tiy[outidx][1],0.0]))
                                coordtransformed = utils.coord_transform_to_quer(np.array([tix[outidx][1],tiy[outidx][1],0.0]))
                                print "tix:",tix[outidx],"coordtransformed:",coordtransformed
                                out[outidx][1] = coordtransformed[0]
                                out[outidx][2] = coordtransformed[1]
                            quermagnitude_coordstransformed_x = out[:,:2]
                            quermagnitude_coordstransformed_y = out[:,[0,2]]

                            np.savetxt(self.fitfolder+'tix'+"_"+shell+"nn_all_parallel_f_coordstransformed_x",quermagnitude_coordstransformed_x,fmt="%.6f")
                            np.savetxt(self.fitfolder+'tiy'+"_"+shell+"nn_all_parallel_f_coordstransformed_y",quermagnitude_coordstransformed_y,fmt="%.6f")
                            # let's now parametrize this functions
                            polyfit(
                                foldername=self.fitfolder,
                                filename='tix'+"_"+shell+"nn_all_parallel_f_coordstransformed_x_poly",
                                        zeroat=0.0,
                                        data=quermagnitude_coordstransformed_x)
                            polyfit(
                                foldername=self.fitfolder,
                                filename='tiy'+"_"+shell+"nn_all_parallel_f_coordstransformed_y_poly",
                                        zeroat=0.0,
                                        data=quermagnitude_coordstransformed_y)




                #print self.funcallmin
                #print self.funcallmax
                #print "0.2:",self.nnxdist-0.2*self.nnxdist,self.nnxdist,self.nnxdist+0.2*self.nnxdist
                #print "0.3:",self.nnxdist-0.3*self.nnxdist,self.nnxdist,self.nnxdist+0.3*self.nnxdist
                # b) save the fit
                # c) in xdir get corresponding fit in quer auslenkung
                # d) calculate tox by substraction of (quer) long part from tox atoms
                # e) calculate tix by substraction of (quer) long part from tix atoms

        return
